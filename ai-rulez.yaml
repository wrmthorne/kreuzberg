$schema: https://github.com/Goldziher/ai-rulez/schema/ai-rules-v2.schema.json

metadata:
  name: Kreuzberg
  version: 4.0.0-rc1
  description: "Rust document intelligence library with polyglot bindings (Python/TypeScript/Ruby/Java/Go/Elixir/C#/PHP)"

presets:
  - claude
  - codex
  - gemini

sections:
  - name: Repository Structure & Commands
    priority: high
    content: |
      **Core**: crates/kreuzberg (Rust 2024, standalone library, Edition 2024)
      **Bindings**: Python (PyO3/maturin), TypeScript (NAPI-RS/pnpm), Ruby (Magnus/rake), Java (FFM API/Maven), Go (cgo/go), Elixir (Rustler/mix), C# (FFI/dotnet), PHP (FFI/composer)
      **Task Commands**: task setup, task build, task test, task lint, task format
      **All E2E generated**: cargo run -p kreuzberg-e2e-generator -- generate --lang <rust|python|typescript|ruby|java|go|elixir>
      **Version sync**: task sync-versions (syncs Cargo.toml → all manifests)

  - name: Rust Latest Edition Standards
    priority: critical
    content: |
      **Rust 2024 edition · High strictness · clippy -D warnings · 95% coverage · Zero unwrap**

      - Rust edition 2024; cargo fmt, clippy with -D warnings (zero tolerance)
      - Result<T, E> for errors; thiserror for custom errors; NEVER .unwrap() in production
      - Testing: 95% minimum coverage (tarpaulin), unit/integration/doc tests
      - Documentation: rustdoc on ALL public items with examples, SAFETY comments for unsafe
      - Async: Tokio 1.x exclusively, 'static constraints, proper Send+Sync bounds
      - FFI: isolated modules, pointer validation, SAFETY comments, error conversion at boundaries
      - Code quality: RAII principle, explicit lifetimes, builder pattern, no panics
      - Pre-commit: cargo fmt, clippy, test, tarpaulin coverage check
      - Never: unwrap in production, unsafe without SAFETY docs, std::thread (use Tokio)

  - name: Rust Kreuzberg-Specific Conventions
    priority: critical
    content: |
      **Edition 2024**: let-chains, gen blocks, if/match guards. **Naming**: PascalCase (types), snake_case (fns/vars/modules), SCREAMING_SNAKE_CASE (consts).

      **Error handling**: Result<T, KreuzbergError>, never .unwrap() in production, use `?`, KreuzbergError::Io always bubbles up (CRITICAL), SAFETY comments for unsafe, handle lock poisoning.

      **Async**: Tokio throughout, #[tokio::main]/#[tokio::test], provide _sync wrappers, never std::thread::sleep.

      **Memory**: Arc for shared ownership, Mutex/RwLock for interior mutability, streaming for large files, RAII patterns.

      **Performance**: ahash for HashMap, lazy_static/once_cell, SIMD where appropriate, zero-copy (&str/&[u8]).

      **Plugins**: Traits (DocumentExtractor, OcrBackend, PostProcessor, Validator), Arc<dyn Trait> storage, Send+Sync, registry pattern.

      **Zero clippy warnings** (cargo clippy -- -D warnings).

      **Core structure**: src/{api,cache,chunking,core,extraction,extractors,image,keywords,language_detection,mcp,ocr,pdf,plugins,stopwords,text,utils}.
      Plugin flow: File→MIME→Registry→Extractor→Pipeline→Result.

  - name: Elixir 1.14+ with ExDoc & Credo
    priority: critical
    content: |
      **Elixir 1.14+ · Functional-first · ExDoc · ExUnit · Rustler NIF**

      - Target Elixir 1.14+ with .tool-versions file; use ASDF for version management
      - Module structure: CamelCase for modules (e.g., Kreuzberg.Native), snake_case for functions/variables
      - ExDoc for documentation: @moduledoc and @doc tags on all public APIs with examples
      - ExUnit for testing: describe/test blocks, 80%+ test coverage, property-based testing with StreamData
      - Credo for linting: strict mode enabled, no ignored warnings
      - Type specifications: @spec, @type, @callback annotations on all public functions
      - Guard clauses and pattern matching for control flow (avoid if/else chains)
      - OTP principles: Supervision trees, GenServer for state, Agent for simple storage
      - Erlang/OTP interoperability: understand BEAM VM concepts (processes, mailboxes, schedulers)
      - Result tuples: {:ok, value} and {:error, reason} patterns (NEVER exceptions for control flow)
      - Immutable data structures: pipelines with |> operator for transformations
      - Pure functions: side effects isolated to GenServer/Agent/NIFs
      - Naming: PascalCase (modules), snake_case (functions), SCREAMING_SNAKE_CASE (module attributes)
      - Code quality: Functions concise (<20 lines), guard clauses, modules for logical organization
      - Rustler NIF: Schedule CPU-intensive work on dirty schedulers (schedule = "DirtyCpu")
      - Binary handling: Use Erlang binaries efficiently, avoid unnecessary copying
      - CI: mix credo --strict, mix test with coverage, mix format --check-formatted, mix docs

  - name: Elixir Kreuzberg Bindings (Rustler NIF)
    priority: high
    content: |
      **Role**: Elixir bindings for Kreuzberg Rust core using Rustler NIF.

      **Scope**:
      - Rust NIF bridge: packages/elixir/native/kreuzberg_rustler/ (Rust crate with cdylib output)
      - Elixir wrapper: packages/elixir/lib/kreuzberg/ (OTP application with public API)
      - ExUnit tests: packages/elixir/test/

      **Architecture**:
      Elixir OTP application → Rustler NIF (kreuzberg_rustler.so) → Rust core (crates/kreuzberg)

      Data flow: Elixir terms → term_to_json → serde_json::Value → Kreuzberg API → serde_json::Value → json_to_term → Elixir terms

      **Commands**:
      - mix deps.get (fetch dependencies)
      - mix compile (compile Elixir + Rustler NIF)
      - mix test (run ExUnit tests)
      - mix credo (lint with Credo)
      - mix format (format code)
      - mix docs (generate ExDoc documentation)

      **Build System**:
      - mix.exs: Elixir project configuration with Rustler dependency
      - Native crate: packages/elixir/native/kreuzberg_rustler/Cargo.toml
      - Compiled NIF: priv/native/kreuzberg_rustler.so (loaded at runtime)
      - Workspace exclusion: Native crate excluded from main Cargo workspace

      **Critical**:
      - Core extraction logic lives in Rust (crates/kreuzberg). Elixir only for bindings/wrappers and OTP integration.
      - If core logic changes needed, coordinate with rust-core-engineer.
      - Rustler handles serialization between Erlang terms and Rust types (NifMap, Binary, ResourceArc).
      - Use dirty schedulers for CPU-intensive work to avoid blocking BEAM schedulers.
      - Resource cleanup: Use ResourceArc for Rust objects that need garbage collection.

      **NIF Patterns** (Phase 2 implementation follows html-to-markdown pattern):
      - rustler::init!() macro registers NIFs with BEAM VM
      - #[rustler::nif] attribute marks functions as NIFs
      - #[rustler::nif(schedule = "DirtyCpu")] for CPU-intensive work on ALL extraction NIFs
      - Field-by-field map construction: rustler::types::map::map_new() + incremental map_put() (NO NifMap derive)
      - term_to_json helper: Elixir term → serde_json::Value (handles atoms, booleans, numbers, strings, lists, maps)
      - json_to_term helper: serde_json::Value → Elixir term (recursive conversion for nested structures)
      - OwnedBinary + Binary for efficient binary data (images): OwnedBinary::new() + Binary::from_owned()
      - ResourceArc<T> for Rust objects with GC integration (reserved for future use)
      - Dual-path config parsing: serde_json deserialization + explicit field handling for boolean fields

      **Config Parsing Approach** (ExtractionConfig):
      1. Accept Elixir map with atom/string keys via Term parameter
      2. Convert term → serde_json::Value using term_to_json helper
      3. Deserialize using serde_json::from_value() for nested structures (ocr, chunking, images, pages, etc.)
      4. Explicitly handle top-level booleans (use_cache, enable_quality_processing, force_ocr) for compatibility
      5. Return default ExtractionConfig if parsing fails at any step

      **Documentation**:
      - All public modules and functions documented with ExDoc (@moduledoc, @doc)
      - Include @spec annotations for all exported functions
      - Examples in module documentation for common use cases
      - README.md with installation, usage, and API overview

  - name: Python Modern & Performance Standards
    priority: critical
    content: |
      **Python 3.10+ · Functional-first · msgspec · Fully async · Strongest typing**

      - Target Python 3.10+; match/case, union types (X | Y), structural pattern matching
      - msgspec ONLY (NEVER pydantic); msgspec.Struct with slots=True, kw_only=True, frozen=True
      - Full type hints: ParamSpec for decorators, TypeVar/Generic[T], Protocol for structural typing
      - Enable mypy --strict --warn-unreachable --disallow-any-expr; never use Any
      - Functional patterns: pure functions, composition, map/filter/reduce, immutability
      - Walrus operator := in comprehensions; match/case for conditionals
      - contextlib.suppress for intentional exception suppression
      - O(1) optimization: dict/set lookups over if/elif chains
      - Fully async: anyio.Path (not pathlib), httpx AsyncClient, asyncpg, asyncio.gather
      - Function-based tests ONLY (*_test.py); pytest fixtures, 95% coverage, real PostgreSQL
      - Never: class tests, pydantic, sync I/O in async, Any type, Optional[T] (use T | None)

  - name: Python Kreuzberg Bindings
    priority: critical
    content: |
      **Role**: Python bindings for Kreuzberg Rust core. Work on PyO3 bridge (crates/kreuzberg-py) and Python wrapper (packages/python/kreuzberg).

      **Scope**: PyO3 FFI, Python-idiomatic API, Python-specific OCR (EasyOCR/PaddleOCR in packages/python/kreuzberg/ocr/), postprocessors.

      **Commands**: maturin develop, pytest, ruff format/check.

      **Critical**: Core logic lives in Rust. Only Python code for bindings, Python-specific OCR, or API wrappers. If core logic needed, coordinate with rust-engineer.

      **Principles**: Function-based tests only, 95% coverage, builtin imports at top, no docstrings in private/test files.

  - name: PyO3 Performance Patterns
    priority: high
    content: |
      Use `pyo3_async_runtimes` for async Python callbacks (~28x faster than spawn_blocking for fast ops).

      Pattern: Check `__await__` attribute, use `pyo3_async_runtimes::tokio::into_future()` for async, fallback to spawn_blocking for sync. Release GIL before awaiting. Use Python::attach() not with_gil().

      spawn_blocking for long ops (OCR), block_in_place for quick ops (PostProcessor/Validator). **CRITICAL: spawn_blocking on PostProcessor/Validator causes GIL deadlocks.**

      Reference: crates/kreuzberg-py/README.md

  - name: TypeScript Strictest Standards
    priority: critical
    content: |
      **TypeScript 5.x · Strictest typing · No any/object · Generics required · Tests next to source**

      - Enable ALL strict flags: strict, noUncheckedIndexedAccess, exactOptionalPropertyTypes
      - Ban any and object types; use unknown with guards, Record<string, unknown>
      - Generics with constraints: <T extends BaseType>, satisfies operator, const assertions
      - Tests: .spec.ts next to source files (NOT __tests__/); vitest, 80%+ coverage
      - Functional: pure functions over classes, map/filter/reduce, immutability, readonly
      - Nullish coalescing ??, optional chaining ?., type predicates (x is Type)
      - Import type for types, organize by feature, path aliases (@/lib/*)
      - Biome for linting/formatting, pnpm ≥10.17, pnpm-lock.yaml committed
      - React: function components, custom hooks (use*), proper prop typing
      - Never: any/object types, __test__ dirs, non-null assertions !, || for defaults

  - name: TypeScript Kreuzberg Bindings
    priority: critical
    content: |
      **Role**: TypeScript bindings for Kreuzberg Rust core. Work on NAPI-RS bridge (crates/kreuzberg-node) and TypeScript SDK (packages/typescript).

      **Scope**: NAPI-RS FFI, TypeScript-idiomatic API, type definitions, JSDoc for all exports with @param/@returns/@example.

      **Commands**: pnpm install/build/test/lint.

      **Critical**: Core logic lives in Rust. TypeScript only for bindings/wrappers. If core logic needed, coordinate with rust-engineer.

  - name: Go 1.25+ Standards
    priority: critical
    content: |
      **Go 1.25+ · Table-driven tests · golangci-lint · Error wrapping · Black-box testing**

      - Go 1.25+; error wrapping with fmt.Errorf("%w", err), errors.Is/As for checking
      - Testing: *_test.go with _test package suffix (black-box), table-driven with t.Run()
      - golangci-lint: errcheck, govet, staticcheck, gosec, gocyclo (complexity ≤25)
      - Coverage 80%+ on business logic; go test -race for concurrency bugs
      - Package structure: cmd/, internal/ (no cross-service imports), pkg/ for libraries
      - Naming: PascalCase (types), camelCase (vars), SCREAMING_SNAKE_CASE (consts)
      - Context.Context first param in I/O funcs; respect cancellation with select <-ctx.Done()
      - Structured logging: zerolog with Str/Int/Err chaining
      - Never: bare error returns, cross-service internal imports, panic in libraries

  - name: Go Kreuzberg Bindings
    priority: high
    content: |
      **Role**: Go bindings for Kreuzberg Rust core. Work on CGO bridge (packages/go/v4) and Go SDK/E2E suite (packages/go/v4 + e2e/go).

      **Scope**: Go 1.25 module, cgo wrappers around kreuzberg-ffi, Go-idiomatic config/result structs, golangci-lint setup, benchmark harness scripts.

      **Commands**: cd packages/go/v4 && go test ./..., golangci-lint run --config ../../.golangci.yml ./..., ensure `LD_LIBRARY_PATH`/`DYLD_LIBRARY_PATH` includes target/release when running tests.

      **FFI**: Binding header (packages/go/v4/binding.go) must stay in sync with kreuzberg-ffi C header. Add new APIs to Rust first, then expose through cgo, update types.go, regenerate Go E2E tests when fixtures change.

      **Critical**: Core logic lives in Rust. Go code should remain thin wrappers/helper utilities over C API. Coordinate with rust-engineer for shared logic.

  - name: Ruby 3.2+ with RBS & Steep
    priority: high
    content: |
      **Ruby 3.2+ · RBS type definitions · Steep · rbenv · RSpec · Rubocop**

      - Ruby 3.2+ with .ruby-version file; rbenv for version management
      - RBS files in sig/ directory parallel to source: lib/foo.rb → sig/foo.rbs
      - Steep for type checking; avoid Any types, use union and optional types explicitly
      - RSpec for testing: describe/context/it blocks, 80%+ coverage, function-like tests
      - Rubocop with auto-fix: line length ≤120, prefer &:method_name blocks
      - Naming: PascalCase (classes), snake_case (methods), SCREAMING_SNAKE_CASE (constants)
      - Code quality: methods <10 lines, guard clauses, modules for mixins, Dry::Struct for value objects
      - CI: rubocop --format progress, steep check, rspec with simplecov

  - name: Ruby Kreuzberg Bindings
    priority: high
    content: |
      **Role**: Ruby bindings for Kreuzberg Rust core. Work on Magnus bridge (packages/ruby/ext/kreuzberg_rb/native) and Ruby gem (packages/ruby).

      **Scope**: Magnus FFI, Ruby-idiomatic API, RSpec tests.

      **Commands**: bundle install, bundle exec rake compile/rubocop/rspec.

      **Critical**: Core logic lives in Rust. Ruby only for bindings/wrappers. If core logic needed, coordinate with rust-engineer.

  - name: Java 25 with FFM API
    priority: high
    content: |
      **Java 25 · FFM API · Checkstyle · PMD · JUnit 5 · Maven/Gradle**

      - Java 25 exclusively; FFM API for native interop, sealed classes, records, pattern matching
      - Build: Maven (pom.xml) or Gradle (build.gradle.kts); compiler release=25
      - JUnit 5: @Nested classes, @ParameterizedTest, AssertJ fluent assertions, 80%+ coverage
      - Checkstyle: 4-space indent, line ≤120 chars, Javadoc on public APIs
      - PMD: UnusedVariable, EmptyCatchBlock, AvoidDuplicateLiterals enabled
      - FFM patterns: Arena for memory management, try-with-resources, bounds validation
      - Naming: PascalCase (classes), camelCase (methods/fields), UPPER_SNAKE_CASE (constants)
      - Best practices: final on classes/methods, immutable records, Optional<T> not null

  - name: Java Kreuzberg Bindings
    priority: high
    content: |
      **Role**: Java bindings for Kreuzberg Rust core. Work on C FFI bridge (crates/kreuzberg-ffi) and Java wrapper (packages/java).

      **Scope**: Java 25 Foreign Function & Memory API (FFM/Panama), Java-idiomatic API, JUnit 5 tests, Javadoc.

      **Architecture**: Java FFM API → kreuzberg-ffi (C library) → Rust core. No JNI, modern Foreign Function API.

      **Commands**: cd packages/java && mvn clean compile test, mvn checkstyle:check, mvn spotless:apply.

      **E2E Tests**: Auto-generated from fixtures via tools/e2e-generator. Regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang java.

      **Critical**: Core logic lives in Rust. Java only for FFI bindings/wrappers. If core logic needed, coordinate with rust-engineer.

      **Key files**: Kreuzberg.java (high-level API), KreuzbergFFI.java (FFI bindings), config/* (builder pattern), KreuzbergException.java (exception hierarchy).

      **Code quality**: Zero Checkstyle/PMD warnings, use mvn checkstyle:check and mvn spotless:apply.

  - name: Error Handling Strategy
    priority: critical
    content: |
      **CRITICAL: OSError/RuntimeError must ALWAYS bubble up** (Python + Rust). SystemExit, KeyboardInterrupt, MemoryError too.

      **Python**: Exception-based, inherit from KreuzbergError. OSError patterns: 1) Library misuse→bubble up, 2) Subprocess→analyze stderr for parsing keywords, 3) Cache→ignore, 4) Dependencies→MissingDependencyError or bubble up. Always add ~keep comments.

      **Rust**: KreuzbergError::Io always bubbles up unchanged. Result<T, KreuzbergError>, never .unwrap() in production, use `?`.

      **Exception hierarchy**: ValidationError, ParsingError, OCRError, MissingDependencyError.

  - name: Testing Philosophy & Coverage
    priority: critical
    content: |
      **Three-tier**: unit (80-95%), integration (real DB/services), E2E (smoke/full)

      **Real infrastructure in tests**: PostgreSQL, Redis, not mocks

      **Rust**: cargo test, #[tokio::test], 95% coverage (tarpaulin), test error paths, edge cases, no panics

      **Python**: Function-based tests only (*_test.py), pytest fixtures, 95% coverage. Structure: tests/{core,features,integration,interfaces,extractors,ocr,utils,e2e}. Test async+sync, error paths. Naming: test_<function>_<scenario>_<outcome>. NEVER mock anyio/asyncio, prefer real objects (tmp_path).

      **TypeScript**: .spec.ts next to source files, vitest, 80%+ coverage

      **Go**: *_test.go with _test package suffix (black-box), table-driven with t.Run(), 80%+ business logic, go test -race

      **Ruby**: RSpec, describe/context/it blocks, 80%+ coverage

      **Java**: JUnit 5, @Test methods, AssertJ, 80%+ coverage. E2E auto-generated from fixtures.

  - name: Documentation Standards & Language Parity
    priority: critical
    content: |
      **CRITICAL: Full language parity required**. ALL documentation, guides, and code examples MUST include snippets for ALL 7 supported languages: Rust, Python, TypeScript, Ruby, Java, Go, C#.

      **Code snippet structure**:
      - Location: docs/snippets/{language}/{category}/{filename}.{ext}
      - Categories: getting-started, config, advanced, ocr, metadata, plugins, api, mcp, cli, utils, cache, docker, benchmarking
      - Use MkDocs pymdownx.tabbed extension for multi-language code blocks
      - Include snippets with --8<-- syntax: `--8<-- "docs/snippets/python/config/basic.py"`

      **Snippet requirements**:
      - Keep concise (10-40 lines per snippet)
      - No comments in snippets (documentation provides context)
      - Verify API accuracy by reading source code before writing
      - Test all snippets for correctness
      - Each language must have equivalent functionality shown

      **Language-specific inline documentation**:
      - **Rust**: /// doc comments on ALL public items, SAFETY comments for unsafe, ~keep suffix for error handling, examples as doctests
      - **Python**: NO docstrings in private/test files, public API only, Google style format
      - **TypeScript**: JSDoc with @param/@returns/@example on ALL exports
      - **Java**: Javadoc on ALL public classes/methods with @param/@return/@throws/@since
      - **Go**: Package doc.go files, inline comments following Go conventions
      - **Ruby**: YARD documentation with @param/@return tags
      - **C#**: XML doc comments with <summary>, <param>, <returns>

      **General rules**:
      - Code comments explain "why" not "what"
      - No proactive README/documentation creation - only when requested
      - No AI signatures in any documentation
      - Cross-reference related APIs across languages
      - Update ALL language snippets when APIs change

  - name: Git & Commit Standards
    priority: critical
    content: |
      - Conventional Commits 1.0.0: feat/fix/docs/refactor/test/chore with scope
      - NEVER include AI signatures ("Generated with Claude") in commits
      - Pre-commit hooks with prek/lefthook/husky: linting, formatting, tests
      - Branch protection: main/development with required status checks

  - name: Task Automation & Build
    priority: critical
    content: |
      - Taskfile.yaml for all workflows: setup, dev, lint, format, test, build
      - Lock files committed: uv.lock, pnpm-lock.yaml, go.sum, Cargo.lock, composer.lock
      - Dependency minimization: justify all external deps, audit regularly
      - Version sync across runtimes: Cargo.toml, package.json, pyproject.toml

  - name: Modular Taskfile Structure
    priority: critical
    content: |
      **Root**: Taskfile.yml (version 3) includes all modular task files from .task/ directory.

      **Configuration Files**:
      - `.task/config/vars.yml`: Global variables (BUILD_PROFILE, VERSION, PDFIUM_VERSION, ORT_VERSION, GOLANGCI_LINT_VERSION, paths, OS/ARCH detection, CARGO_PROFILE_DIR mapping)
      - `.task/config/platforms.yml`: Platform-specific variables (EXE_EXT, LIB_EXT, NUM_CPUS with comprehensive Windows/Linux/macOS support)

      **Language Files** (namespaced tasks):
      - `.task/languages/rust.yml`: Rust build/test/format/lint tasks
      - `.task/languages/python.yml`: Python build/test/format/lint tasks
      - `.task/languages/node.yml`: TypeScript/Node.js build/test/format/lint tasks
      - `.task/languages/go.yml`: Go build/test/lint tasks
      - `.task/languages/java.yml`: Java build/test/lint tasks
      - `.task/languages/csharp.yml`: C# build/test tasks
      - `.task/languages/wasm.yml`: WebAssembly build/test tasks
      - `.task/languages/ruby.yml`: Ruby build/test/lint tasks
      - `.task/languages/php.yml`: PHP build/test/lint tasks

      **Workflow Orchestration Files** (internal, cross-language):
      - `.task/workflows/build.yml`: build, build:all, build:all:dev, build:all:release
      - `.task/workflows/test.yml`: test, test:all, test:all:fast
      - `.task/workflows/lint.yml`: lint, lint:all, lint:check
      - `.task/workflows/e2e.yml`: e2e, e2e:all, e2e:fast

      **Tool Task Files**:
      - `.task/tools/general.yml`: setup, clean, setup-pre-commit, pre-commit
      - `.task/tools/version-sync.yml`: version:sync (sync version across all manifests)
      - `.task/tools/pdfium.yml`: pdfium:install, pdfium:setup
      - `.task/tools/pre-commit.yml`: pre-commit configuration
      - `.task/tools/docs.yml`: Documentation generation tasks
      - `.task/tools/smoke.yml`: Smoke tests
      - `.task/test-config.yml`: Test configuration

      **Namespace Convention**:
      - Language tasks: `task rust:build`, `task python:test`, `task node:lint`
      - Workflow tasks: `task build:all`, `task test:all`, `task lint:check`
      - Tool tasks: `task version:sync`, `task pdfium:install`, `task setup`, `task clean`

  - name: Build Profiles
    priority: critical
    content: |
      **BUILD_PROFILE environment variable controls build mode** (default: "release").

      **Available Profiles**:
      1. **dev**: Fast iteration, debug symbols, no optimizations. Use for development/testing.
         - Cargo profile: debug
         - Optimization: -C opt-level=0
         - Usage: `BUILD_PROFILE=dev task rust:build` or `task rust:build:dev`

      2. **release**: Optimized production builds, minimal debug symbols. Use for production/benchmarking.
         - Cargo profile: release
         - Optimization: -C opt-level=3
         - Usage: `BUILD_PROFILE=release task rust:build` or `task rust:build:release`

      3. **ci**: Release optimizations + debug symbols for troubleshooting. Use in CI/CD pipelines.
         - Cargo profile: release
         - Debug: enabled
         - Usage: `BUILD_PROFILE=ci task rust:build` (automatically set in GitHub Actions)

      **Profile Mapping**:
      - `BUILD_PROFILE=dev` → CARGO_PROFILE_DIR=debug
      - `BUILD_PROFILE=release` → CARGO_PROFILE_DIR=release
      - `BUILD_PROFILE=ci` → CARGO_PROFILE_DIR=release (but with debug info)

      **Usage Examples**:
      ```bash
      # Dev builds (fast, debug symbols)
      BUILD_PROFILE=dev task rust:build
      BUILD_PROFILE=dev task build:all

      # Release builds (optimized)
      BUILD_PROFILE=release task rust:build
      task build:all:release

      # CI builds (optimized + debug)
      BUILD_PROFILE=ci task build:all
      ```

  - name: Common Task Commands
    priority: critical
    content: |
      **Setup & Installation**:
      - `task setup`: Install all dependencies (Rust, Python, Node, Go, Java, Ruby, etc.)
      - `task setup-pre-commit`: Configure pre-commit hooks

      **Build Commands**:
      - `task build`: Build all (respects BUILD_PROFILE)
      - `task build:all`: Build all languages
      - `task build:all:dev`: Build all in debug mode
      - `task build:all:release`: Build all in release mode
      - `task rust:build`: Build Rust core (respects BUILD_PROFILE)
      - `task rust:build:dev`: Build Rust in debug mode
      - `task rust:build:release`: Build Rust in release mode
      - `task python:build`: Build Python bindings (maturin)
      - `task node:build`: Build TypeScript/Node bindings (NAPI-RS)
      - `task go:build`: Build Go bindings
      - `task java:build`: Build Java bindings (Maven)
      - `task ruby:build`: Compile Ruby native extensions
      - `task csharp:build`: Build C# bindings
      - `task wasm:build`: Build WebAssembly bindings

      **Test Commands**:
      - `task test`: Run tests (respects BUILD_PROFILE)
      - `task test:all`: Run all tests across all languages
      - `task test:all:fast`: Run fast tests (skip slow integration tests)
      - `task rust:test`: Run Rust tests
      - `task python:test`: Run Python tests (pytest)
      - `task node:test`: Run TypeScript tests (vitest)
      - `task go:test`: Run Go tests
      - `task java:test`: Run Java tests (Maven)
      - `task ruby:test`: Run Ruby tests (RSpec)
      - `task e2e`: Run E2E tests
      - `task e2e:all`: Run all E2E tests across all languages

      **Linting & Formatting**:
      - `task lint`: Lint current project
      - `task lint:all`: Lint all languages
      - `task lint:check`: CI linting (for GitHub Actions, fails on issues)
      - `task format`: Format code (auto-fixes)
      - `task format:check`: Check formatting (fails if needs formatting)
      - `task rust:fmt`: Format Rust (cargo fmt)
      - `task rust:clippy`: Lint Rust (cargo clippy)
      - `task python:lint`: Lint Python (ruff, mypy)
      - `task python:format`: Format Python (ruff, black)
      - `task node:lint`: Lint TypeScript (biome)
      - `task node:format`: Format TypeScript (biome)

      **Utilities**:
      - `task clean`: Clean build artifacts
      - `task version:sync`: Sync version from Cargo.toml to all manifests (package.json, pyproject.toml, pom.xml, go.mod, Gemfile, etc.)
      - `task pre-commit`: Run pre-commit hooks manually
      - `task pdfium:install`: Download and install PDFium library
      - `task smoke`: Run smoke tests (quick validation)

  - name: Platform Support & Cross-Platform Compatibility
    priority: critical
    content: |
      **Supported Platforms**: Windows (via Git Bash/MSYS2/MinGW/PowerShell), Linux (all major distributions), macOS (Intel & ARM/M-series).

      **Platform Detection in Taskfiles**:
      - `{{.OS}}`: Detects operating system (windows, linux, darwin)
        - Windows detection: PowerShell, GOOS env, WINDIR/SYSTEMROOT, MSYSTEM (Git Bash/MSYS2/MinGW)
        - Linux/macOS: uname fallback with comprehensive error handling
      - `{{.ARCH}}`: Detects CPU architecture (x86_64, arm64, etc.)
      - `{{.EXE_EXT}}`: Platform-specific executable extension (.exe on Windows, empty on Unix)
      - `{{.LIB_EXT}}`: Platform-specific library extension (dll on Windows, dylib on macOS, so on Linux)
      - `{{.NUM_CPUS}}`: CPU count for parallel builds (PowerShell/sysctl/nproc/cpuinfo detection)

      **Platform Guards in Task Files**:
      - Use conditional commands: `cmd: "script.sh"; platforms: [linux, darwin]`
      - Windows-specific: `cmd: "script.bat"; platforms: [windows]`
      - Darwin-specific: `cmd: "script.sh"; platforms: [darwin]`
      - Example: Cargo commands work on all platforms (Rust toolchain cross-platform)

      **Cross-Platform Best Practices**:
      1. Use Taskfile variables instead of hardcoded paths ({{.ROOT}}, {{.CRATES_DIR}})
      2. Use forward slashes in paths; Taskfile converts to backslashes on Windows
      3. Avoid shell-specific features; use platform-agnostic task commands
      4. For scripts: create separate .sh (Unix) and .bat/.ps1 (Windows) files if needed
      5. Test on Windows, Linux, and macOS in CI (or locally via Docker)

      **Environment Variables for Cross-Platform**:
      - `LD_LIBRARY_PATH` (Linux): Add target/release/target/debug for FFI tests
      - `DYLD_LIBRARY_PATH` (macOS): Add target/release/target/debug for FFI tests
      - `PATH` (Windows): Automatically uses backslashes for library lookup

  - name: CI/CD Pipeline Standards
    priority: critical
    content: |
      **Architecture**: Stages: Validate (lint/format) → Build → Test (unit/integration) → Deploy. Quality gates: zero warnings, tests pass, coverage thresholds met.

      **Multi-platform Testing**: linux/amd64, linux/arm64, macOS (Intel/ARM). Docker: multi-stage builds, minimal base images (alpine/distroless).

      **Artifact Management**: Cache dependencies (Cargo, npm, Maven, Go modules). Publish packages (PyPI/npm/crates.io/Maven Central).

      **CI Workflows Use Task Commands**:
      - Workflows now ALWAYS use `task` commands, never direct script calls
      - All CI workflows automatically set `BUILD_PROFILE=ci`
      - Example workflow structure:
        ```yaml
        - name: Setup
          run: task setup
        - name: Lint
          run: task lint:check
        - name: Build
          run: BUILD_PROFILE=ci task build:all
        - name: Test
          run: BUILD_PROFILE=ci task test:all
        - name: E2E
          run: BUILD_PROFILE=ci task e2e:all
        ```

      **BUILD_PROFILE in CI**: Always set `BUILD_PROFILE=ci` in GitHub Actions workflows:
      - Provides release-optimized binaries
      - Includes debug symbols for troubleshooting
      - Consistent with local development workflow
      - Use `task lint:check` for CI-specific linting (fails on issues vs. warnings)

      **Pre-commit Hooks in CI**: GitHub Actions runs `task pre-commit` in validate stage to catch linting/formatting issues early

  - name: Workspace Structure & Project Organization
    priority: high
    content: |
      **Rust workspace** (Cargo.toml): crates/{kreuzberg,kreuzberg-py,kreuzberg-node,kreuzberg-ffi,kreuzberg-cli}, packages/ruby/ext/kreuzberg_rb/native, tools/{benchmark-harness,e2e-generator}, e2e/{rust,go}.

      **Language packages**: packages/{python,typescript,ruby,java,go} - thin wrappers around Rust core.

      **E2E tests**: Auto-generated from fixtures/ via tools/e2e-generator. Located in e2e/{rust,python,typescript,ruby,java,go}.

      **Benchmarking**: Rust harness in tools/benchmark-harness.

      **Install**: `uv sync --all-extras --all-packages --all-groups`.

      **Version sync**: `task sync-versions` (syncs from Cargo.toml to all manifests).

  - name: Test Apps - Published Package Validation
    priority: high
    content: |
      **Purpose**: tests/test_apps validates PUBLISHED/RELEASED packages from npm, PyPI, RubyGems, Maven Central, Docker Hub, and Homebrew. NOT for local development testing.

      **Location**: tests/test_apps/{python,node,wasm,ruby,go,java,csharp,rust,docker,homebrew,browser-vite-svelte}

      **Version sync**: Included in `task sync-versions` - automatically updates all test app manifests to match Cargo.toml version. Supports all package formats: pyproject.toml, package.json, Gemfile, go.mod, pom.xml, .csproj, Cargo.toml.

      **Linting**: Pre-commit hooks (biome, shellcheck, ruff) apply to test_apps. CPD checks excluded (intentional duplication for testing).

      **Usage**: Each test app installs the published package and runs comprehensive tests. Run from kreuzberg repo root: `cd tests/test_apps/{language} && {language-specific-test-command}`

      **Documentation**: tests/test_apps/README.md contains full details on running tests for each language.

      **Critical**: Test apps are for validating releases, not development. Use e2e/ tests for development validation.

  - name: Taskfile Best Practices & Guidelines
    priority: high
    content: |
      **Modular Design Principles**:
      - Each language gets its own task file in `.task/languages/`
      - Workflows (build, test, lint, e2e) are orchestrated internally in `.task/workflows/`
      - Configuration separated into `.task/config/` (vars.yml, platforms.yml)
      - Tool tasks in `.task/tools/` (version-sync, pdfium, pre-commit, docs, smoke)
      - Main Taskfile.yml is minimal - just includes and top-level entry points

      **Creating New Task Files**:
      1. Create `.task/languages/{language}.yml` for language-specific tasks
      2. Include in main Taskfile.yml: `{language}: taskfile: .task/languages/{language}.yml`
      3. Use namespace pattern: `task {language}:build`, `task {language}:test`
      4. Support BUILD_PROFILE for dev/release/ci variants
      5. Include both `.dev` and `.release` variants of build/test tasks

      **Variable Management**:
      - Global variables in `.task/config/vars.yml` (BUILD_PROFILE, VERSION, paths, OS/ARCH)
      - Platform-specific in `.task/config/platforms.yml` (EXE_EXT, LIB_EXT, NUM_CPUS)
      - Language-specific vars in language files (e.g., PYTHON_VERSION, RUST_LOG)
      - Avoid hardcoding paths; use {{.ROOT}}, {{.CRATES_DIR}}, {{.PACKAGES_DIR}}, {{.TARGET_DIR}}
      - Use {{.BUILD_PROFILE}} to determine debug vs. release builds
      - Use {{.OS}}, {{.ARCH}}, {{.EXE_EXT}}, {{.LIB_EXT}} for cross-platform support

      **Task Naming Convention**:
      - Language tasks: `task {language}:{action}` (e.g., rust:build, python:test, node:lint)
      - Workflow tasks: `task {workflow}:{scope}` (e.g., build:all, test:all:fast, lint:check)
      - Tool tasks: `task {tool}:{action}` (e.g., version:sync, pdfium:install)
      - Variants: `:dev`, `:release`, `:ci`, `:fast`, `:check`

      **Task Description Standards**:
      - Write task `desc` field for every task (used in `task --list`)
      - Be descriptive: "Build Rust core in release mode" not just "Build Rust"
      - Include BUILD_PROFILE if relevant: "Lint Python (uses ruff, mypy)"

      **Cross-Platform Considerations**:
      - Test commands on Windows, Linux, macOS before committing
      - Use Taskfile path conventions (forward slashes converted automatically)
      - Set `platforms: [linux, darwin]` or `platforms: [windows]` if OS-specific
      - Use ENV variables for library paths: LD_LIBRARY_PATH (Linux), DYLD_LIBRARY_PATH (macOS)

      **Error Handling**:
      - Always set `requires: ["task"]` or ensure task is available
      - Use `ignore_error: true` sparingly; prefer explicit error handling
      - Run pre-flight checks (e.g., version checks) in setup tasks
      - Clear error messages for dependencies (e.g., "Install Rust via rustup")

      **Caching & Performance**:
      - Leverage {{.NUM_CPUS}} for parallel builds: `cargo build -j {{.NUM_CPUS}}`
      - Cache dependencies between CI runs (Cargo.lock, npm-lock.yaml, etc.)
      - Use `:fast` variants for quick validation; full tests in separate task
      - Reuse tasks: `task rust:build` instead of duplicating build commands

      **Documentation & Discovery**:
      - Run `task --list` to see all available tasks (requires good desc fields)
      - Run `task {language}:` to list all tasks in a namespace
      - Update README when adding new major workflows
      - Link to task files from docs when documenting CLI usage

  - name: Core Principles
    priority: critical
    content: |
      **Do only what's asked. Never create files unnecessarily. Prefer editing. No proactive docs/READMEs.**

      **Python**: Builtin imports at top, dataclasses frozen/hashable/slots, function-based tests only.

      **Rust**: Never .unwrap() in production, SAFETY comments for unsafe, handle lock poisoning.

      **Architecture**: ALL extraction logic lives in Rust core. Bindings provide language-idiomatic APIs only.

  - name: Universal Anti-Patterns
    priority: critical
    content: |
      **Never use:**
      - Any type (Python, TypeScript) - use Unknown/generics
      - Class-based tests (Python) - function-based only
      - Mocking internal services (any language) - use real objects
      - Manual dependency management - use lock files
      - Blocking I/O in async code (Python/TypeScript) - fully async paths
      - Bare exception handlers - catch specific types only
      - Magic numbers - extract to named constants
      - Inheritance for code reuse - prefer composition
      - Global state - dependency injection
      - f-strings in logging - structured key=value logging

  - name: Agent Selection & Usage Guidelines
    priority: critical
    content: |
      **When to use agents**: Use the Task tool to spawn specialized agents for focused, language-specific work. Agents provide domain expertise and follow language-specific conventions.

      **Agent selection rules**:
      - **Rust core work** → rust-core-engineer (core library, extraction logic, plugins)
      - **Python bindings** → python-bindings-engineer (PyO3 FFI, Python wrappers, EasyOCR/PaddleOCR)
      - **TypeScript bindings** → typescript-bindings-engineer (NAPI-RS FFI, TS SDK)
      - **Ruby bindings** → ruby-bindings-engineer (Magnus FFI, Ruby gem)
      - **Java bindings** → java-bindings-engineer (FFM API, Java wrappers)
      - **Go bindings** → go-bindings-engineer (cgo FFI, Go SDK)
      - **Testing tasks** → test-automation-engineer (unit/integration/E2E across all languages)
      - **Code review** → code-reviewer (quality, security, compliance checks)
      - **Architecture/planning** → polyglot-architect (FFI design, multi-language coordination)
      - **User guides/tutorials** → docs-writer (user-facing documentation, multi-language examples)
      - **API documentation** → api-doc-writer (inline docs, API reference pages)
      - **Learning materials** → tutorial-writer (step-by-step guides, getting started content)

      **Multi-language tasks**: If work spans multiple languages (e.g., Rust core + bindings), spawn multiple agents in parallel when possible.

      **Performance**: All implementation agents use haiku (fast, cost-effective). Only polyglot-architect uses sonnet for strategic planning.

      **Agent coordination**: Rust-first principle - core logic goes in rust-core-engineer first, then binding engineers expose through language-idiomatic APIs. Binding engineers should coordinate with rust-core-engineer for shared logic.

      **When NOT to use agents**: Simple edits, single-file changes, or tasks you can complete directly without specialized domain knowledge.

agents:
  - name: polyglot-architect
    description: System design and multi-language architecture decisions
    system_prompt: |
      Strategic leadership for Kreuzberg polyglot architecture. Expertise: multi-language FFI design (Rust→Python/TypeScript/Ruby/Java/Go), version syncing, E2E test generation, cross-platform compatibility (linux/macOS), plugin system design.

      Responsibilities: Architecture ADRs, FFI boundary design, language-binding coordination, performance tradeoffs across languages, dependency management across Cargo/npm/PyPI/Maven/Go modules.

      Key principle: Rust core is single source of truth; all bindings are thin wrappers exposing language-idiomatic APIs.
    model: sonnet

  - name: rust-core-engineer
    description: Rust core library development (PRIMARY)
    system_prompt: |
      **PRIMARY ROLE**: Rust engineer for Kreuzberg - this is a Rust-first repository. The core library (crates/kreuzberg) is a standalone Rust library. ALL extraction logic lives here.

      **Structure**: crates/kreuzberg/src/{api,cache,chunking,core,extraction,extractors,image,keywords,language_detection,mcp,ocr,pdf,plugins,stopwords,text,utils}.

      **Expertise**: Edition 2024, Tokio async, plugin system (DocumentExtractor, OcrBackend, PostProcessor, Validator), performance (SIMD, streaming, zero-copy).

      **Commands**: cargo build/test/clippy/fmt, maturin develop (for bindings).

      **Principles**: Never .unwrap() in production, SAFETY comments for unsafe, Result<T, KreuzbergError>, KreuzbergError::Io bubbles up, 95% coverage, doc comments for ALL public items.

      **Key**: New features go in Rust core first, then expose through bindings.
    model: haiku

  - name: python-bindings-engineer
    description: PyO3 bindings and Python wrapper development
    system_prompt: |
      **Role**: Python bindings for Kreuzberg Rust core. Work on PyO3 bridge (crates/kreuzberg-py) and Python wrapper (packages/python/kreuzberg).

      **Scope**: PyO3 FFI, Python-idiomatic API, Python-specific OCR (EasyOCR/PaddleOCR in packages/python/kreuzberg/ocr/), postprocessors.

      **Commands**: maturin develop, pytest, ruff format/check.

      **Critical**: Core logic lives in Rust. Only Python code for bindings, Python-specific OCR, or API wrappers. If core logic needed, coordinate with rust-core-engineer.

      **Principles**: Function-based tests only, 95% coverage, builtin imports at top. Use pyo3_async_runtimes for async callbacks.
    model: haiku

  - name: typescript-bindings-engineer
    description: NAPI-RS bindings and TypeScript SDK development
    system_prompt: |
      **Role**: TypeScript bindings for Kreuzberg Rust core. Work on NAPI-RS bridge (crates/kreuzberg-node) and TypeScript SDK (packages/typescript).

      **Scope**: NAPI-RS FFI, TypeScript-idiomatic API, type definitions, JSDoc for all exports.

      **Commands**: pnpm install/build/test/lint.

      **Critical**: Core logic lives in Rust. TypeScript only for bindings/wrappers. If core logic needed, coordinate with rust-core-engineer.

      **Standards**: Strictest TS flags (strict, noUncheckedIndexedAccess, exactOptionalPropertyTypes), ban any/object, use Biome linting/formatting.
    model: haiku

  - name: ruby-bindings-engineer
    description: Magnus FFI bindings and Ruby gem development
    system_prompt: |
      **Role**: Ruby bindings for Kreuzberg Rust core. Work on Magnus bridge (packages/ruby/ext/kreuzberg_rb/native) and Ruby gem (packages/ruby).

      **Scope**: Magnus FFI, Ruby-idiomatic API, RSpec tests.

      **Commands**: bundle install, bundle exec rake compile/rubocop/rspec.

      **Critical**: Core logic lives in Rust. Ruby only for bindings/wrappers. If core logic needed, coordinate with rust-core-engineer.
    model: haiku

  - name: java-bindings-engineer
    description: FFM API bindings and Java wrapper development
    system_prompt: |
      **Role**: Java bindings for Kreuzberg Rust core. Work on C FFI bridge (crates/kreuzberg-ffi) and Java wrapper (packages/java).

      **Scope**: Java 25 Foreign Function & Memory API (FFM/Panama), Java-idiomatic API, JUnit 5 tests, Javadoc.

      **Architecture**: Java FFM API → kreuzberg-ffi (C library) → Rust core. No JNI, modern Foreign Function API.

      **Commands**: cd packages/java && mvn clean compile test, mvn checkstyle:check, mvn spotless:apply.

      **E2E Tests**: Auto-generated from fixtures via tools/e2e-generator. Regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang java.

      **Critical**: Core logic lives in Rust. Java only for FFI bindings/wrappers. If core logic needed, coordinate with rust-core-engineer.

      **Key files**: Kreuzberg.java (high-level API), KreuzbergFFI.java (FFI bindings), config/* (builder pattern), KreuzbergException.java (exception hierarchy).
    model: haiku

  - name: go-bindings-engineer
    description: cgo bindings and Go SDK development
    system_prompt: |
      **Role**: Go bindings for Kreuzberg Rust core. Work on CGO bridge (packages/go/v4) and Go SDK/E2E suite (packages/go/v4 + e2e/go).

      **Scope**: Go 1.25 module, cgo wrappers around kreuzberg-ffi, Go-idiomatic config/result structs, golangci-lint setup, benchmark harness scripts.

      **Commands**: cd packages/go/v4 && go test ./..., golangci-lint run --config ../../.golangci.yml ./..., ensure `LD_LIBRARY_PATH`/`DYLD_LIBRARY_PATH` includes target/release when running tests.

      **Critical**: Core logic lives in Rust. Go code should remain thin wrappers/helper utilities over the C API. Coordinate with rust-core-engineer for shared logic.

      **FFI Sync**: Binding header (packages/go/v4/binding.go) must stay in sync with kreuzberg-ffi C header. Regenerate Go E2E tests when fixtures change.
    model: haiku

  - name: test-automation-engineer
    description: Testing across all language bindings and E2E verification
    system_prompt: |
      **Primary**: Test Rust core (crates/kreuzberg) - cargo test, #[tokio::test], 95% coverage, fixtures in fixtures/ directory.

      **Secondary**: Test bindings - pytest (Python), pnpm test (TypeScript), bundle exec rspec (Ruby), mvn test (Java), go test ./... (Go).

      **E2E**: Auto-generated from fixtures via tools/e2e-generator. Located in e2e/{rust,python,typescript,ruby,java,go}. Regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang <lang>.

      **Naming**: test_<function>_<scenario>_<outcome> (Rust/Python). Test error paths, edge cases, real objects over mocks.

      **Rust-first**: Ensure core is thoroughly tested before bindings. 95% min coverage on core, 80%+ on bindings.
    model: haiku

  - name: code-reviewer
    description: Quality, security, and compliance review
    system_prompt: |
      **Review checklist**: 1) Implementation gaps (error handling, type hints, SAFETY comments), 2) Redundancies (DRY principle), 3) Correctness (logic, async safety, FFI boundaries), 4) Rule adherence (file creation, 95% coverage on core, no unwrap/Any/class tests), 5) Security (injection, validation, pointer safety), 6) Performance (caching, memory leaks, SIMD opportunities, zero-copy patterns).

      **Rate findings**: Critical/High/Medium/Low.

      **FFI focus**: Verify SAFETY comments for unsafe blocks, pointer validation, error conversion at boundaries.

      **Cross-language**: Ensure Rust core logic isn't duplicated in bindings; verify idiomatic APIs per language.
    model: haiku

  - name: docs-writer
    description: Technical documentation, guides, and tutorials
    system_prompt: |
      **Role**: Create and maintain technical documentation for Kreuzberg. Write user guides, API documentation, tutorials, and code examples.

      **Scope**: Documentation in docs/, README files, code snippets in docs/snippets/, inline code examples, MkDocs content.

      **Standards**:
      - Clear, concise technical writing with concrete examples
      - Code snippets for ALL supported languages (Rust, Python, TypeScript, Ruby, Java, Go, C#)
      - Use MkDocs markdown format with pymdownx.tabbed for multi-language examples
      - Verify API accuracy by reading actual source code before documenting
      - Keep examples minimal and focused on single concepts
      - Use --8<-- syntax for snippet inclusion from docs/snippets/

      **Guidelines**:
      - No proactive documentation - only write when requested
      - No AI signatures in documentation
      - Test all code examples for correctness
      - Follow language-specific documentation standards (rustdoc, JSDoc, Javadoc, docstrings)
      - Cross-reference related APIs and concepts

      **Critical**: Always validate API signatures against actual source code. Never document features that don't exist.
    model: haiku

  - name: api-doc-writer
    description: API reference documentation and inline code documentation
    system_prompt: |
      **Role**: Write inline API documentation (rustdoc, JSDoc, Javadoc, docstrings) and maintain API reference pages.

      **Scope**: Doc comments in source code, API reference pages in docs/api/, type definitions, function signatures.

      **Standards by language**:
      - **Rust**: /// doc comments on ALL public items, SAFETY comments for unsafe, examples as doctests
      - **Python**: Docstrings on public API only (not private/test files), Google style format
      - **TypeScript**: JSDoc with @param/@returns/@example on all exports
      - **Java**: Javadoc on ALL public classes/methods with @param/@return/@throws/@since
      - **Go**: Package doc.go files and inline comments following Go conventions
      - **Ruby**: YARD documentation with @param and @return tags
      - **C#**: XML doc comments with <summary>, <param>, <returns>

      **Guidelines**:
      - Explain "why" not "what" in code comments
      - Include practical usage examples
      - Document edge cases and error conditions
      - Link to related APIs
      - Keep descriptions concise and accurate

      **Critical**: Verify all documented APIs exist and signatures are correct by reading source code.
    model: haiku

  - name: tutorial-writer
    description: Step-by-step tutorials and learning guides
    system_prompt: |
      **Role**: Create beginner-friendly tutorials and learning paths for Kreuzberg users.

      **Scope**: Getting started guides, feature tutorials, migration guides, best practices documentation.

      **Structure**:
      - Clear learning objectives at the start
      - Step-by-step instructions with expected output
      - Progressive complexity (basic → intermediate → advanced)
      - Troubleshooting sections for common issues
      - Links to relevant API documentation

      **Guidelines**:
      - Write for users new to the library but experienced in their language
      - Include complete, runnable code examples
      - Show both simple and real-world usage patterns
      - Explain trade-offs and when to use different approaches
      - Add visual aids (diagrams, screenshots) where helpful

      **Critical**: Test all tutorial code to ensure it works. Never assume features exist - verify against source.
    model: haiku
