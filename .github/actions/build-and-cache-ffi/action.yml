name: Build and Cache FFI Libraries
description: Build FFI libraries with intelligent caching based on Rust source hashes

inputs:
  platform:
    description: 'Platform identifier (e.g., linux-x64, macos-arm64, windows-x64)'
    required: true
  ffi-crate:
    description: 'FFI crate to build (kreuzberg-ffi, kreuzberg-py, kreuzberg-rb, kreuzberg-php)'
    required: true
  cache-version:
    description: 'Manual version for cache invalidation'
    required: false
    default: 'v1'
  skip-build-on-hit:
    description: 'Skip build if cache hit (default: true)'
    required: false
    default: 'true'
  pdfium-version:
    description: 'PDFium version (used for cache key)'
    required: false
    default: ''
  ort-version:
    description: 'ORT runtime version (used for cache key)'
    required: false
    default: ''

outputs:
  cache-hit:
    description: 'Boolean indicating exact cache hit'
    value: ${{ steps.cache-restore.outputs.cache-hit }}
  cache-key:
    description: 'The cache key used'
    value: ${{ steps.generate-cache-key.outputs.cache-key }}
  rust-hash:
    description: 'The Rust source hash (for use in dependent binding caches)'
    value: ${{ steps.generate-cache-key.outputs.rust-hash }}
  library-path:
    description: 'Path to the built FFI library'
    value: ${{ steps.build.outputs.library-path }}

runs:
  using: composite
  steps:
    # Validation
    - name: Validate inputs
      shell: bash
      env:
        PLATFORM: ${{ inputs.platform }}
        FFI_CRATE: ${{ inputs.ffi-crate }}
      run: |
        set -euo pipefail

        # Validate platform
        if [[ -z "$PLATFORM" ]]; then
          echo "❌ Error: platform is required"
          exit 1
        fi

        # Validate ffi-crate
        valid_crates=("kreuzberg-ffi" "kreuzberg-py" "kreuzberg-rb" "kreuzberg-php")
        if [[ ! " ${valid_crates[@]} " =~ " ${FFI_CRATE} " ]]; then
          echo "❌ Error: ffi-crate must be one of: ${valid_crates[*]}"
          exit 1
        fi

        echo "✓ Validation passed"
        echo "  Platform: $PLATFORM"
        echo "  FFI Crate: $FFI_CRATE"

    # Generate hash for Rust sources
    - name: Compute Rust source hash
      id: rust-hash
      shell: bash
      run: |
        set -euo pipefail

        # Compute hash for all Rust source files
        RUST_HASH=$(scripts/ci/cache/compute-hash.sh \
          "crates/kreuzberg/**/*.rs" \
          "crates/kreuzberg-ffi/**/*.rs" \
          "crates/kreuzberg-tesseract/**/*.rs" \
          2>&1 | grep "^[a-f0-9]*$")

        if [[ -z "$RUST_HASH" ]]; then
          echo "❌ Failed to compute Rust source hash"
          exit 1
        fi

        echo "rust-hash=$RUST_HASH" >> "$GITHUB_OUTPUT"
        echo "✓ Rust source hash: $RUST_HASH"

    # Generate hash for Cargo files
    - name: Compute Cargo files hash
      id: cargo-hash
      shell: bash
      run: |
        set -euo pipefail

        # Compute hash for Cargo.toml and Cargo.lock
        CARGO_HASH=$(scripts/ci/cache/compute-hash.sh --files Cargo.toml Cargo.lock 2>&1 | grep "^[a-f0-9]*$")

        if [[ -z "$CARGO_HASH" ]]; then
          echo "❌ Failed to compute Cargo files hash"
          exit 1
        fi

        echo "cargo-hash=$CARGO_HASH" >> "$GITHUB_OUTPUT"
        echo "✓ Cargo files hash: $CARGO_HASH"

    # Generate cache key
    - name: Generate cache key
      id: generate-cache-key
      shell: bash
      env:
        FFI_CRATE: ${{ inputs.ffi-crate }}
        PLATFORM: ${{ inputs.platform }}
        RUST_HASH: ${{ steps.rust-hash.outputs.rust-hash }}
        CARGO_HASH: ${{ steps.cargo-hash.outputs.cargo-hash }}
        PDFIUM_VERSION: ${{ inputs.pdfium-version || env.PDFIUM_VERSION || '0' }}
        ORT_VERSION: ${{ inputs.ort-version || env.ORT_VERSION || '0' }}
        CACHE_VERSION: ${{ inputs.cache-version }}
      run: |
        set -euo pipefail

        # Build cache key following format:
        # ffi-{crate}-{platform}-rust-{rust-hash}-cargo-{cargo-hash}-pdfium-{ver}-ort-{ver}-{cache-version}
        CACHE_KEY="ffi-${FFI_CRATE}-${PLATFORM}-rust-${RUST_HASH}-cargo-${CARGO_HASH}-pdfium-${PDFIUM_VERSION}-ort-${ORT_VERSION}-${CACHE_VERSION}"

        echo "cache-key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
        echo "rust-hash=$RUST_HASH" >> "$GITHUB_OUTPUT"

        echo "=== Cache Key Generated ==="
        echo "Full key: $CACHE_KEY"
        echo ""
        echo "Key components:"
        echo "  Crate:          $FFI_CRATE"
        echo "  Platform:       $PLATFORM"
        echo "  Rust hash:      $RUST_HASH"
        echo "  Cargo hash:     $CARGO_HASH"
        echo "  PDFium version: $PDFIUM_VERSION"
        echo "  ORT version:    $ORT_VERSION"
        echo "  Cache version:  $CACHE_VERSION"

    # Determine target-specific directory
    - name: Determine build target directory
      id: target-dir
      shell: bash
      run: |
        set -euo pipefail

        TARGET_DIR="${CARGO_TARGET_DIR:-target}"

        # If CARGO_BUILD_TARGET is set, use target-specific subdirectory
        if [[ -n "${CARGO_BUILD_TARGET:-}" ]]; then
          RELEASE_DIR="$TARGET_DIR/$CARGO_BUILD_TARGET/release"
          echo "release-dir=$RELEASE_DIR" >> "$GITHUB_OUTPUT"
          echo "Using target-specific directory: $RELEASE_DIR"
        else
          RELEASE_DIR="$TARGET_DIR/release"
          echo "release-dir=$RELEASE_DIR" >> "$GITHUB_OUTPUT"
          echo "Using default directory: $RELEASE_DIR"
        fi

    # Restore from cache
    - name: Restore FFI library from cache
      id: cache-restore
      uses: ./.github/actions/cache-binding-artifact
      with:
        binding-name: ${{ inputs.ffi-crate }}
        cache-key: ${{ steps.generate-cache-key.outputs.cache-key }}
        cache-restore-keys: |
          ffi-${{ inputs.ffi-crate }}-${{ inputs.platform }}-rust-
          ffi-${{ inputs.ffi-crate }}-${{ inputs.platform }}-
        cache-paths: |
          ${{ steps.target-dir.outputs.release-dir }}/
          crates/kreuzberg-ffi/kreuzberg-ffi.pc
        operation: restore

    # Skip build if cache hit (optional)
    - name: Log cache hit status
      shell: bash
      run: |
        if [[ "${{ steps.cache-restore.outputs.cache-hit }}" == "true" ]]; then
          echo "✓ Cache HIT - FFI library found in cache"
          if [[ "${{ inputs.skip-build-on-hit }}" == "true" ]]; then
            echo "⏭️  Skipping build step"
          fi
        else
          echo "✗ Cache MISS - Building FFI library from source"
        fi

    # Build if cache miss or skip-build-on-hit is false
    - name: Build FFI library
      id: build
      if: steps.cache-restore.outputs.cache-hit != 'true' || inputs.skip-build-on-hit != 'true'
      shell: bash
      env:
        FFI_CRATE: ${{ inputs.ffi-crate }}
      run: |
        set -euo pipefail

        echo "=== Building FFI Library ==="
        echo "Crate: $FFI_CRATE"

        # Build the specified FFI crate
        echo "Building FFI crate: $FFI_CRATE"

        # Preserve existing RUSTFLAGS and add debug info
        export RUSTFLAGS="${RUSTFLAGS:-} -C debuginfo=2"
        echo "RUSTFLAGS: $RUSTFLAGS"

        # Run the build with appropriate package flag
        if ! cargo build --release --package "$FFI_CRATE"; then
          echo "❌ Build failed for $FFI_CRATE"
          exit 1
        fi

        # Detect library path based on FFI crate
        TARGET_DIR="${CARGO_TARGET_DIR:-target}"

        # Determine release directory (with target-specific subdirectory if CARGO_BUILD_TARGET is set)
        if [[ -n "${CARGO_BUILD_TARGET:-}" ]]; then
          RELEASE_DIR="$TARGET_DIR/$CARGO_BUILD_TARGET/release"
        else
          RELEASE_DIR="$TARGET_DIR/release"
        fi

        # Determine library name - check Cargo.toml for custom lib name
        CARGO_TOML="crates/${FFI_CRATE}/Cargo.toml"

        if [[ -f "$CARGO_TOML" ]] && grep -q '^\[lib\]' "$CARGO_TOML"; then
          # Extract custom library name from Cargo.toml if it exists
          CUSTOM_LIB_NAME=$(awk '/^\[lib\]/,/^\[/ {if ($1 == "name") {gsub(/"/, "", $3); print $3}}' "$CARGO_TOML")
          if [[ -n "$CUSTOM_LIB_NAME" ]]; then
            LIB_NAME="$CUSTOM_LIB_NAME"
          else
            # Convert crate name to library name (replace hyphens with underscores)
            LIB_NAME="${FFI_CRATE//-/_}"
          fi
        else
          # Convert crate name to library name (replace hyphens with underscores)
          LIB_NAME="${FFI_CRATE//-/_}"
        fi

        echo "Library name: $LIB_NAME"

        LIBRARY_PATH=""
        for candidate in "$RELEASE_DIR/lib${LIB_NAME}.so" \
                         "$RELEASE_DIR/lib${LIB_NAME}.dylib" \
                         "$RELEASE_DIR/${LIB_NAME}.dll" \
                         "$RELEASE_DIR/lib${LIB_NAME}.a"; do
          if [[ -e "$candidate" ]]; then
            LIBRARY_PATH="$candidate"
            break
          fi
        done

        if [[ -z "$LIBRARY_PATH" ]]; then
          echo "❌ No library file found after build"
          exit 1
        fi

        echo "library-path=$LIBRARY_PATH" >> "$GITHUB_OUTPUT"
        echo "✓ Build succeeded"
        echo "  Library: $LIBRARY_PATH"

    # Validate cached artifacts
    - name: Validate FFI artifacts
      shell: bash
      run: |
        set -euo pipefail

        echo "=== Validating FFI Artifacts ==="

        # Use the release directory determined earlier
        RELEASE_DIR="${{ steps.target-dir.outputs.release-dir }}"
        echo "Validating artifacts in: $RELEASE_DIR"

        # Run validation script with directory path
        scripts/ci/cache/validate-cache.sh ffi "$RELEASE_DIR/" || {
          echo "❌ Validation failed"
          exit 1
        }

        echo "✓ All artifacts validated"

    # Save to cache if build occurred
    - name: Save FFI library to cache
      if: steps.cache-restore.outputs.cache-hit != 'true' || inputs.skip-build-on-hit != 'true'
      uses: ./.github/actions/cache-binding-artifact
      with:
        binding-name: ${{ inputs.ffi-crate }}
        cache-key: ${{ steps.generate-cache-key.outputs.cache-key }}
        cache-paths: |
          ${{ steps.target-dir.outputs.release-dir }}/
          crates/kreuzberg-ffi/kreuzberg-ffi.pc
        operation: save

    # Summary
    - name: Summary
      if: always()
      shell: bash
      run: |
        echo ""
        echo "=== Build and Cache Summary ==="
        echo "FFI Crate:     ${{ inputs.ffi-crate }}"
        echo "Platform:      ${{ inputs.platform }}"
        echo "Cache Hit:     ${{ steps.cache-restore.outputs.cache-hit == 'true' && 'Yes' || 'No' }}"
        echo "Cache Key:     ${{ steps.generate-cache-key.outputs.cache-key }}"
        echo "Rust Hash:     ${{ steps.generate-cache-key.outputs.rust-hash }}"

        if [[ -n "${{ steps.build.outputs.library-path }}" ]]; then
          echo "Library Path:  ${{ steps.build.outputs.library-path }}"
        fi
