name: Build and Cache Language Binding
description: >
  Build language-specific bindings with intelligent caching.
  Generates cache keys based on Rust FFI hash + binding files + dependencies,
  restores from cache if available, builds if needed, and saves to cache.
  Validates cached artifacts to ensure integrity.

inputs:
  binding-name:
    description: 'Language binding name (python, ruby, go, java, csharp, php, node, wasm)'
    required: true

  platform:
    description: 'Platform identifier (e.g., linux-x86_64, macos-arm64, windows-x86_64)'
    required: true

  task-command:
    description: 'Task command to run for building (e.g., python:build:ci, node:build:release)'
    required: true

  cache-paths:
    description: 'Newline-separated list of paths to cache (e.g., dist/, build/)'
    required: true

  cache-version:
    description: 'Manual cache version override (default: v1)'
    required: false
    default: 'v1'

  rust-hash:
    description: 'Rust FFI source hash (from FFI build) to include in cache key'
    required: true

  binding-files:
    description: 'Glob pattern for binding-specific source files (e.g., bindings/python/** or use multiple patterns separated by newlines)'
    required: true

  dep-files:
    description: 'Dependency lock files to hash (newline-separated, e.g., Cargo.lock or pyproject.toml)'
    required: true

  enable-crossplatform-cache:
    description: 'Enable cross-OS caching (experimental, may have issues)'
    required: false
    default: 'false'

  validate-artifacts:
    description: 'Enable artifact validation after cache restore or build'
    required: false
    default: 'true'

outputs:
  cache-hit:
    description: 'Whether the cache was restored (exact match)'
    value: ${{ steps.restore-cache.outputs.cache-hit }}

  cache-key:
    description: 'The full cache key that was used'
    value: ${{ steps.compute-keys.outputs.cache-key }}

  cache-matched-key:
    description: 'The cache key that was actually matched (exact or partial)'
    value: ${{ steps.restore-cache.outputs.cache-matched-key || steps.compute-keys.outputs.cache-key }}

  binding-hash:
    description: 'Hash of binding-specific source files'
    value: ${{ steps.compute-hashes.outputs.binding-hash }}

  deps-hash:
    description: 'Hash of dependency lock files'
    value: ${{ steps.compute-hashes.outputs.deps-hash }}

  artifact-validated:
    description: 'Whether cached artifacts passed validation'
    value: ${{ steps.validate.outputs.validated }}

runs:
  using: composite

  steps:
    - name: Validate inputs
      shell: bash
      run: |
        set -euo pipefail

        echo "=== Input Validation ==="

        if [[ -z "${{ inputs.binding-name }}" ]]; then
          echo "❌ Error: binding-name is required"
          exit 1
        fi

        if [[ -z "${{ inputs.platform }}" ]]; then
          echo "❌ Error: platform is required"
          exit 1
        fi

        if [[ -z "${{ inputs.task-command }}" ]]; then
          echo "❌ Error: task-command is required"
          exit 1
        fi

        if [[ -z "${{ inputs.cache-paths }}" ]]; then
          echo "❌ Error: cache-paths is required"
          exit 1
        fi

        if [[ -z "${{ inputs.rust-hash }}" ]]; then
          echo "❌ Error: rust-hash is required"
          exit 1
        fi

        if [[ -z "${{ inputs.binding-files }}" ]]; then
          echo "❌ Error: binding-files is required"
          exit 1
        fi

        if [[ -z "${{ inputs.dep-files }}" ]]; then
          echo "❌ Error: dep-files is required"
          exit 1
        fi

        echo "✓ Binding: ${{ inputs.binding-name }}"
        echo "✓ Platform: ${{ inputs.platform }}"
        echo "✓ Task: ${{ inputs.task-command }}"
        echo "✓ Cache version: ${{ inputs.cache-version }}"

    - name: Compute cache hashes
      id: compute-hashes
      shell: bash
      run: |
        set -euo pipefail

        SCRIPT_DIR="${{ github.action_path }}/../../.."
        HASH_SCRIPT="$SCRIPT_DIR/scripts/ci/cache/compute-hash.sh"

        if [[ ! -f "$HASH_SCRIPT" ]]; then
          echo "❌ Error: compute-hash.sh script not found at $HASH_SCRIPT"
          exit 1
        fi

        echo "=== Computing Binding Hash ==="

        # Process binding-files patterns (may contain newlines)
        BINDING_FILES_PATTERNS="${{ inputs.binding-files }}"
        BINDING_HASH=$("$HASH_SCRIPT" $BINDING_FILES_PATTERNS || echo "unknown")

        if [[ "$BINDING_HASH" == "unknown" ]]; then
          echo "⚠ Warning: Could not compute binding hash, using placeholder"
          BINDING_HASH="nofiles"
        fi

        echo "  Binding hash: $BINDING_HASH"
        echo "binding-hash=$BINDING_HASH" >> "$GITHUB_OUTPUT"

        echo "=== Computing Dependencies Hash ==="

        # Process dep-files (may contain newlines)
        DEP_FILES="${{ inputs.dep-files }}"
        DEPS_HASH=$("$HASH_SCRIPT" --files $DEP_FILES || echo "unknown")

        if [[ "$DEPS_HASH" == "unknown" ]]; then
          echo "⚠ Warning: Could not compute deps hash, using placeholder"
          DEPS_HASH="nodeps"
        fi

        echo "  Dependencies hash: $DEPS_HASH"
        echo "deps-hash=$DEPS_HASH" >> "$GITHUB_OUTPUT"

    - name: Compute cache keys
      id: compute-keys
      shell: bash
      run: |
        set -euo pipefail

        BINDING_NAME="${{ inputs.binding-name }}"
        PLATFORM="${{ inputs.platform }}"
        RUST_HASH="${{ inputs.rust-hash }}"
        BINDING_HASH="${{ steps.compute-hashes.outputs.binding-hash }}"
        DEPS_HASH="${{ steps.compute-hashes.outputs.deps-hash }}"
        CACHE_VERSION="${{ inputs.cache-version }}"

        echo "=== Cache Key Computation ==="

        # Primary cache key: exact match required for perfect cache hit
        CACHE_KEY="${BINDING_NAME}-${PLATFORM}-rust-${RUST_HASH}-binding-${BINDING_HASH}-deps-${DEPS_HASH}-${CACHE_VERSION}"

        echo "  Binding: $BINDING_NAME"
        echo "  Platform: $PLATFORM"
        echo "  Rust hash: $RUST_HASH"
        echo "  Binding hash: $BINDING_HASH"
        echo "  Deps hash: $DEPS_HASH"
        echo "  Version: $CACHE_VERSION"
        echo ""
        echo "  Primary key: $CACHE_KEY"

        echo "cache-key=$CACHE_KEY" >> "$GITHUB_OUTPUT"

        # Fallback restore keys (partial matches for cache misses)
        # Try 1: Same binding/platform/rust, different binding/deps
        RESTORE_KEY_1="${BINDING_NAME}-${PLATFORM}-rust-${RUST_HASH}-"
        # Try 2: Same binding/platform, different rust
        RESTORE_KEY_2="${BINDING_NAME}-${PLATFORM}-"
        # Try 3: Same binding, different platform
        RESTORE_KEY_3="${BINDING_NAME}-"

        echo "fallback-keys<<EOF" >> "$GITHUB_OUTPUT"
        echo "$RESTORE_KEY_1" >> "$GITHUB_OUTPUT"
        echo "$RESTORE_KEY_2" >> "$GITHUB_OUTPUT"
        echo "$RESTORE_KEY_3" >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"

    - name: Restore binding from cache
      id: restore-cache
      uses: ./.github/actions/cache-binding-artifact
      with:
        binding-name: ${{ inputs.binding-name }}
        cache-key: ${{ steps.compute-keys.outputs.cache-key }}
        cache-restore-keys: ${{ steps.compute-keys.outputs.fallback-keys }}
        cache-paths: ${{ inputs.cache-paths }}
        operation: restore
        enable-crossplatform-cache: ${{ inputs.enable-crossplatform-cache }}

    - name: Check if cache hit
      id: cache-check
      shell: bash
      run: |
        set -euo pipefail

        if [[ "${{ steps.restore-cache.outputs.cache-hit }}" == "true" ]]; then
          echo "CACHE_HIT=true" >> "$GITHUB_ENV"
          echo "✓ Cache HIT - Using cached artifacts"
        else
          echo "CACHE_HIT=false" >> "$GITHUB_ENV"
          echo "⚠ Cache MISS - Will build binding"
        fi

    - name: Validate restored artifacts
      id: validate
      if: steps.restore-cache.outputs.cache-hit == 'true' && inputs.validate-artifacts == 'true'
      shell: bash
      run: |
        set -euo pipefail

        SCRIPT_DIR="${{ github.action_path }}/../../.."
        VALIDATE_SCRIPT="$SCRIPT_DIR/scripts/ci/cache/validate-cache.sh"

        if [[ ! -f "$VALIDATE_SCRIPT" ]]; then
          echo "⚠ Warning: validate-cache.sh script not found at $VALIDATE_SCRIPT"
          echo "validated=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "=== Validating Cached Artifacts ==="

        BINDING_NAME="${{ inputs.binding-name }}"
        CACHE_PATHS="${{ inputs.cache-paths }}"

        # Prepare paths for validation script
        ARTIFACT_PATHS=""
        while IFS= read -r path; do
          if [[ -n "$path" ]]; then
            ARTIFACT_PATHS="$ARTIFACT_PATHS $path"
          fi
        done <<< "$CACHE_PATHS"

        if "$VALIDATE_SCRIPT" "$BINDING_NAME" $ARTIFACT_PATHS; then
          echo "validated=true" >> "$GITHUB_OUTPUT"
          echo "✓ Artifacts validation passed"
        else
          echo "validated=false" >> "$GITHUB_OUTPUT"
          echo "✗ Artifacts validation failed - will rebuild"
          exit 0
        fi

    - name: Build binding if cache missed
      id: build
      if: env.CACHE_HIT == 'false'
      shell: bash
      run: |
        set -euo pipefail

        echo "=== Building ${{ inputs.binding-name }} Binding ==="
        echo "Task command: ${{ inputs.task-command }}"

        # Run the Task command to build the binding
        task ${{ inputs.task-command }}

        if [[ $? -eq 0 ]]; then
          echo "✓ Build completed successfully"
        else
          echo "❌ Build failed"
          exit 1
        fi

    - name: Validate build artifacts
      if: env.CACHE_HIT == 'false' && inputs.validate-artifacts == 'true'
      shell: bash
      run: |
        set -euo pipefail

        SCRIPT_DIR="${{ github.action_path }}/../../.."
        VALIDATE_SCRIPT="$SCRIPT_DIR/scripts/ci/cache/validate-cache.sh"

        if [[ ! -f "$VALIDATE_SCRIPT" ]]; then
          echo "⚠ Warning: validate-cache.sh script not found"
          exit 0
        fi

        echo "=== Validating Built Artifacts ==="

        BINDING_NAME="${{ inputs.binding-name }}"
        CACHE_PATHS="${{ inputs.cache-paths }}"

        # Prepare paths for validation script
        ARTIFACT_PATHS=""
        while IFS= read -r path; do
          if [[ -n "$path" ]]; then
            ARTIFACT_PATHS="$ARTIFACT_PATHS $path"
          fi
        done <<< "$CACHE_PATHS"

        if "$VALIDATE_SCRIPT" "$BINDING_NAME" $ARTIFACT_PATHS; then
          echo "✓ Built artifacts validation passed"
        else
          echo "❌ Built artifacts validation failed"
          exit 1
        fi

    - name: Save binding to cache
      if: env.CACHE_HIT == 'false'
      uses: ./.github/actions/cache-binding-artifact
      with:
        binding-name: ${{ inputs.binding-name }}
        cache-key: ${{ steps.compute-keys.outputs.cache-key }}
        cache-paths: ${{ inputs.cache-paths }}
        operation: save
        enable-crossplatform-cache: ${{ inputs.enable-crossplatform-cache }}

    - name: Report build and cache status
      if: always()
      shell: bash
      run: |
        set -euo pipefail

        echo ""
        echo "╔════════════════════════════════════════════════════════════╗"
        echo "║ Build and Cache Summary: ${{ inputs.binding-name }}        "
        echo "╚════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Binding:          ${{ inputs.binding-name }}"
        echo "Platform:         ${{ inputs.platform }}"
        echo "Task Command:     ${{ inputs.task-command }}"
        echo ""
        echo "Hashes:"
        echo "  Rust:           ${{ inputs.rust-hash }}"
        echo "  Binding:        ${{ steps.compute-hashes.outputs.binding-hash }}"
        echo "  Dependencies:   ${{ steps.compute-hashes.outputs.deps-hash }}"
        echo ""
        echo "Cache:"
        echo "  Primary Key:    ${{ steps.compute-keys.outputs.cache-key }}"
        echo "  Hit:            ${{ steps.restore-cache.outputs.cache-hit == 'true' && '✓ Yes' || '✗ No' }}"

        if [[ "${{ steps.restore-cache.outputs.cache-hit }}" != "true" ]]; then
          echo "  Matched Key:    ${{ steps.restore-cache.outputs.cache-matched-key || 'None' }}"
        fi

        echo ""
        echo "Paths Cached:"
        echo "${{ inputs.cache-paths }}" | while IFS= read -r path; do
          if [[ -n "$path" ]]; then
            if [[ -e "$path" ]] || ls "$path" 1>/dev/null 2>&1; then
              SIZE=$(du -sh "$path" 2>/dev/null | cut -f1 || echo "unknown")
              echo "  ✓ $path ($SIZE)"
            else
              echo "  ⚠ $path (not found)"
            fi
          fi
        done

        echo ""
