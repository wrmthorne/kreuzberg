# Migration Guide: v4.1 → v4.2

## Overview

Kreuzberg v4.2 introduces **new output format options** and **enhanced content transformation** capabilities while maintaining **full backward compatibility** with v4.1. All existing v4.1 code continues to work without modification.

### What's New

- **Dual output formats**: Control both content formatting (`plain`, `markdown`, `djot`, `html`) and result structure (`unified`, `element_based`)
- **Element-based output**: Unstructured.io-compatible semantic element extraction with metadata
- **Djot format support**: Extract and convert to Djot markup (Git-friendly lightweight markup)
- **Text chunking API**: New POST `/chunk` endpoint for splitting text into smaller pieces with metadata

### Backward Compatibility

✅ **100% backward compatible** - v4.1 code requires no changes.
- Old `output_format` parameter maintained with backward compatibility
- Default behavior unchanged when new options not specified
- All breaking changes from v4.0 remain unchanged

---

## New Features (Optional)

### 1. Output Format Configuration

v4.2 introduces two independent format axes:

#### Axis 1: Content Format (What the text looks like)

Controls the markup/formatting of extracted text:

| Format | Use Case | Example |
|--------|----------|---------|
| `plain` | Plain text (no markup) | Clean text for NLP/embeddings |
| `markdown` | Markdown markup | *Default*, readable, widely supported |
| `djot` | Djot markup | Git-friendly, lightweight |
| `html` | HTML markup | Web display, rich formatting |

#### Axis 2: Result Format (How the result is structured)

Controls the structure of the entire result object:

| Format | Use Case | Return Value |
|--------|----------|--------------|
| `unified` | Flat text representation | Single `text` field with all content |
| `element_based` | Semantic elements | Array of `Element` objects with metadata |

### 2. Element-Based Output (NEW)

Extract content as structured semantic elements instead of a flat text blob.

**Element types available:**
- `title` - Document title
- `heading` - Section headings with level
- `paragraph` - Text paragraphs
- `list_item` - List items (ordered, unordered, task lists)
- `table` - Structured table data
- `image` - Image references with alt text
- `code_block` - Code with language hints
- `block_quote` - Quoted text
- `page_break` - Document page boundaries
- `header` - Document headers
- `footer` - Document footers

Each element includes rich metadata:
```json
{
  "type": "paragraph",
  "text": "Content here",
  "metadata": {
    "page_number": 1,
    "bounding_box": { "x0": 10, "y0": 20, "x1": 100, "y1": 40 },
    "confidence_score": 0.95,
    "hierarchy_level": 0
  }
}
```

### 3. Djot Format Support (NEW)

Djot is a lightweight markup language similar to Markdown but Git-friendly and more consistent.

**Key differences from Markdown:**
- Uses `` {.attr} `` syntax instead of Markdown's inconsistent attribute handling
- More consistent syntax across list types
- Better support for semantic HTML attributes
- Easier to parse and roundtrip

---

## Migration: No Action Required

All v4.1 code continues to work unmodified. New features are completely optional and backward compatible.

### Example: Unchanged Code Still Works

**Python (v4.1 & v4.2):**
```python
from kreuzberg import extract

# This still works exactly as before
result = extract("document.pdf")
print(result.text)  # Plain text output, unified result format
```

**TypeScript (v4.1 & v4.2):**
```typescript
import { extract } from 'kreuzberg';

// This still works exactly as before
const result = await extract('document.pdf');
console.log(result.text);  // Plain text output, unified result format
```

**Ruby (v4.1 & v4.2):**
```ruby
require 'kreuzberg'

# This still works exactly as before
result = Kreuzberg.extract('document.pdf')
puts result.text  # Plain text output, unified result format
```

---

## Opt-In: New Features

### Use Case 1: Generate Markdown Output (Easy Migration)

You now have explicit control over the output format. This is useful when you need Markdown with metadata.

**Python (v4.2 - NEW):**
```python
from kreuzberg import extract

# Request Markdown formatted text
result = extract(
    "document.pdf",
    output_format="markdown"  # NEW: explicit format control
)
print(result.text)  # Markdown formatted text
```

**TypeScript (v4.2 - NEW):**
```typescript
import { extract } from 'kreuzberg';

// Request Markdown formatted text
const result = await extract('document.pdf', {
    outputFormat: 'markdown'  // NEW: explicit format control
});
console.log(result.text);  // Markdown formatted text
```

**Ruby (v4.2 - NEW):**
```ruby
require 'kreuzberg'

# Request Markdown formatted text
result = Kreuzberg.extract(
    'document.pdf',
    output_format: :markdown  # NEW: explicit format control
)
puts result.text  # Markdown formatted text
```

**PHP (v4.2 - NEW):**
```php
<?php
use Kreuzberg\Kreuzberg;

// Request Markdown formatted text
$result = Kreuzberg::extract(
    'document.pdf',
    ['output_format' => 'markdown']  // NEW: explicit format control
);
echo $result->text;  // Markdown formatted text
?>
```

**Go (v4.2 - NEW):**
```go
package main

import (
    "fmt"
    kreuzberg "github.com/kreuzberg/kreuzberg-go/v2"
)

func main() {
    config := kreuzberg.NewExtractionConfig()
    config.OutputFormat = "markdown"  // NEW: explicit format control

    result, err := kreuzberg.Extract("document.pdf", config)
    if err != nil {
        panic(err)
    }
    fmt.Println(result.Text)  // Markdown formatted text
}
```

**Java (v4.2 - NEW):**
```java
import com.kreuzberg.Kreuzberg;
import com.kreuzberg.ExtractionConfig;

ExtractionConfig config = new ExtractionConfig();
config.setOutputFormat("markdown");  // NEW: explicit format control

ExtractionResult result = Kreuzberg.extract("document.pdf", config);
System.out.println(result.getText());  // Markdown formatted text
```

**C# (v4.2 - NEW):**
```csharp
using Kreuzberg;

var config = new ExtractionConfig
{
    OutputFormat = "markdown"  // NEW: explicit format control
};

var result = await Kreuzberg.ExtractAsync("document.pdf", config);
Console.WriteLine(result.Text);  // Markdown formatted text
```

**Elixir (v4.2 - NEW):**
```elixir
require Kreuzberg

# Request Markdown formatted text
result = Kreuzberg.extract(
    "document.pdf",
    output_format: :markdown  # NEW: explicit format control
)
IO.puts(result.text)  # Markdown formatted text
```

**WASM (v4.2 - NEW):**
```javascript
import { extract } from '@kreuzberg/wasm';

// Request Markdown formatted text
const result = await extract('document.pdf', {
    outputFormat: 'markdown'  // NEW: explicit format control
});
console.log(result.text);  // Markdown formatted text
```

### Use Case 2: Extract Semantic Elements (Unstructured.io Migration)

If you're migrating from Unstructured.io or need semantic structure instead of flat text:

**Python (v4.2 - NEW):**
```python
from kreuzberg import extract

# Get structured elements instead of flat text
result = extract(
    "document.pdf",
    result_format="element_based"  # NEW: semantic element extraction
)

for element in result.elements:
    print(f"{element.type}: {element.text}")
    print(f"  Page: {element.metadata.page_number}")
    print(f"  Confidence: {element.metadata.confidence_score}")
    print()
```

**TypeScript (v4.2 - NEW):**
```typescript
import { extract } from 'kreuzberg';

// Get structured elements instead of flat text
const result = await extract('document.pdf', {
    resultFormat: 'element_based'  // NEW: semantic element extraction
});

for (const element of result.elements ?? []) {
    console.log(`${element.type}: ${element.text}`);
    console.log(`  Page: ${element.metadata?.pageNumber}`);
    console.log(`  Confidence: ${element.metadata?.confidenceScore}`);
    console.log();
}
```

**Ruby (v4.2 - NEW):**
```ruby
require 'kreuzberg'

# Get structured elements instead of flat text
result = Kreuzberg.extract(
    'document.pdf',
    result_format: :element_based  # NEW: semantic element extraction
)

result.elements&.each do |element|
  puts "#{element.type}: #{element.text}"
  puts "  Page: #{element.metadata.page_number}"
  puts "  Confidence: #{element.metadata.confidence_score}"
  puts
end
```

**PHP (v4.2 - NEW):**
```php
<?php
use Kreuzberg\Kreuzberg;

// Get structured elements instead of flat text
$result = Kreuzberg::extract(
    'document.pdf',
    ['result_format' => 'element_based']  // NEW: semantic element extraction
);

foreach ($result->elements ?? [] as $element) {
    echo "{$element->type}: {$element->text}\n";
    echo "  Page: {$element->metadata->page_number}\n";
    echo "  Confidence: {$element->metadata->confidence_score}\n";
    echo "\n";
}
?>
```

**Go (v4.2 - NEW):**
```go
package main

import (
    "fmt"
    kreuzberg "github.com/kreuzberg/kreuzberg-go/v2"
)

func main() {
    config := kreuzberg.NewExtractionConfig()
    config.ResultFormat = "element_based"  // NEW: semantic element extraction

    result, err := kreuzberg.Extract("document.pdf", config)
    if err != nil {
        panic(err)
    }

    for _, element := range result.Elements {
        fmt.Printf("%s: %s\n", element.Type, element.Text)
        fmt.Printf("  Page: %d\n", element.Metadata.PageNumber)
        fmt.Printf("  Confidence: %f\n", element.Metadata.ConfidenceScore)
        fmt.Println()
    }
}
```

**Java (v4.2 - NEW):**
```java
import com.kreuzberg.Kreuzberg;
import com.kreuzberg.ExtractionConfig;
import com.kreuzberg.Element;

ExtractionConfig config = new ExtractionConfig();
config.setResultFormat("element_based");  // NEW: semantic element extraction

ExtractionResult result = Kreuzberg.extract("document.pdf", config);

for (Element element : result.getElements()) {
    System.out.printf("%s: %s%n", element.getType(), element.getText());
    System.out.printf("  Page: %d%n", element.getMetadata().getPageNumber());
    System.out.printf("  Confidence: %f%n", element.getMetadata().getConfidenceScore());
    System.out.println();
}
```

**C# (v4.2 - NEW):**
```csharp
using Kreuzberg;

var config = new ExtractionConfig
{
    ResultFormat = "element_based"  // NEW: semantic element extraction
};

var result = await Kreuzberg.ExtractAsync("document.pdf", config);

foreach (var element in result.Elements ?? Array.Empty<Element>())
{
    Console.WriteLine($"{element.Type}: {element.Text}");
    Console.WriteLine($"  Page: {element.Metadata?.PageNumber}");
    Console.WriteLine($"  Confidence: {element.Metadata?.ConfidenceScore}");
    Console.WriteLine();
}
```

**Elixir (v4.2 - NEW):**
```elixir
require Kreuzberg

# Get structured elements instead of flat text
result = Kreuzberg.extract(
    "document.pdf",
    result_format: :element_based  # NEW: semantic element extraction
)

Enum.each(result.elements, fn element ->
  IO.puts("#{element.type}: #{element.text}")
  IO.puts("  Page: #{element.metadata.page_number}")
  IO.puts("  Confidence: #{element.metadata.confidence_score}")
  IO.puts("")
end)
```

**WASM (v4.2 - NEW):**
```javascript
import { extract } from '@kreuzberg/wasm';

// Get structured elements instead of flat text
const result = await extract('document.pdf', {
    resultFormat: 'element_based'  // NEW: semantic element extraction
});

for (const element of result.elements ?? []) {
    console.log(`${element.type}: ${element.text}`);
    console.log(`  Page: ${element.metadata?.pageNumber}`);
    console.log(`  Confidence: ${element.metadata?.confidenceScore}`);
    console.log();
}
```

### Use Case 3: Combine Both Options

Get Markdown-formatted elements for semantic extraction with formatted text:

**Python (v4.2 - NEW):**
```python
from kreuzberg import extract

result = extract(
    "document.pdf",
    output_format="markdown",     # Format text as Markdown
    result_format="element_based"  # Structure as elements
)

for element in result.elements:
    print(f"## {element.type}")
    print(element.text)  # Already formatted as Markdown
    print()
```

**TypeScript (v4.2 - NEW):**
```typescript
import { extract } from 'kreuzberg';

const result = await extract('document.pdf', {
    outputFormat: 'markdown',    // Format text as Markdown
    resultFormat: 'element_based' // Structure as elements
});

for (const element of result.elements ?? []) {
    console.log(`## ${element.type}`);
    console.log(element.text);  // Already formatted as Markdown
    console.log();
}
```

### Use Case 4: Convert to Djot Format

Extract content and convert to Djot markup:

**Python (v4.2 - NEW):**
```python
from kreuzberg import extract

result = extract(
    "document.pdf",
    output_format="djot"  # NEW: Djot format support
)

print(result.text)  # Content formatted as Djot markup
```

**TypeScript (v4.2 - NEW):**
```typescript
import { extract } from 'kreuzberg';

const result = await extract('document.pdf', {
    outputFormat: 'djot'  // NEW: Djot format support
});

console.log(result.text);  // Content formatted as Djot markup
```

**Ruby (v4.2 - NEW):**
```ruby
require 'kreuzberg'

result = Kreuzberg.extract(
    'document.pdf',
    output_format: :djot  # NEW: Djot format support
)

puts result.text  # Content formatted as Djot markup
```

### Use Case 5: Chunk Text (NEW API)

Split text into smaller pieces for embedding/LLM processing:

**Python (v4.2 - NEW):**
```python
from kreuzberg import chunk

chunks = chunk(
    "Your long text here...",
    chunker_type="markdown",  # Support markdown structure
    config={
        "max_characters": 1000,
        "overlap": 100,
        "trim": True
    }
)

for i, chunk_obj in enumerate(chunks):
    print(f"Chunk {i}:")
    print(f"  Text: {chunk_obj.text}")
    print(f"  Start byte: {chunk_obj.byte_start_index}")
    print(f"  End byte: {chunk_obj.byte_end_index}")
    print(f"  Character index: {chunk_obj.char_start_index}")
    print()
```

**TypeScript (v4.2 - NEW):**
```typescript
import { chunk } from 'kreuzberg';

const chunks = await chunk('Your long text here...', {
    chunkerType: 'markdown',
    config: {
        maxCharacters: 1000,
        overlap: 100,
        trim: true
    }
});

chunks.forEach((chunk, i) => {
    console.log(`Chunk ${i}:`);
    console.log(`  Text: ${chunk.text}`);
    console.log(`  Start byte: ${chunk.byteStartIndex}`);
    console.log(`  End byte: ${chunk.byteEndIndex}`);
    console.log(`  Character index: ${chunk.charStartIndex}`);
    console.log();
});
```

**Ruby (v4.2 - NEW):**
```ruby
require 'kreuzberg'

chunks = Kreuzberg.chunk(
    "Your long text here...",
    chunker_type: :markdown,
    config: {
        max_characters: 1000,
        overlap: 100,
        trim: true
    }
)

chunks.each_with_index do |chunk, i|
  puts "Chunk #{i}:"
  puts "  Text: #{chunk.text}"
  puts "  Start byte: #{chunk.byte_start_index}"
  puts "  End byte: #{chunk.byte_end_index}"
  puts "  Character index: #{chunk.char_start_index}"
  puts
end
```

**PHP (v4.2 - NEW):**
```php
<?php
use Kreuzberg\Kreuzberg;

$chunks = Kreuzberg::chunk(
    "Your long text here...",
    'markdown',
    [
        'max_characters' => 1000,
        'overlap' => 100,
        'trim' => true
    ]
);

foreach ($chunks as $i => $chunk) {
    echo "Chunk $i:\n";
    echo "  Text: {$chunk->text}\n";
    echo "  Start byte: {$chunk->byte_start_index}\n";
    echo "  End byte: {$chunk->byte_end_index}\n";
    echo "  Character index: {$chunk->char_start_index}\n";
    echo "\n";
}
?>
```

**Go (v4.2 - NEW):**
```go
package main

import (
    "fmt"
    kreuzberg "github.com/kreuzberg/kreuzberg-go/v2"
)

func main() {
    config := kreuzberg.NewChunkingConfig()
    config.MaxCharacters = 1000
    config.Overlap = 100
    config.Trim = true

    chunks, err := kreuzberg.Chunk("Your long text here...", "markdown", config)
    if err != nil {
        panic(err)
    }

    for i, chunk := range chunks {
        fmt.Printf("Chunk %d:\n", i)
        fmt.Printf("  Text: %s\n", chunk.Text)
        fmt.Printf("  Start byte: %d\n", chunk.ByteStartIndex)
        fmt.Printf("  End byte: %d\n", chunk.ByteEndIndex)
        fmt.Printf("  Character index: %d\n", chunk.CharStartIndex)
        fmt.Println()
    }
}
```

---

## Configuration Reference

### Extraction Config: New Fields

All language bindings support these new optional fields in the extraction configuration:

| Field | Type | Options | Default | Description |
|-------|------|---------|---------|-------------|
| `output_format` | string | `plain`, `markdown`, `djot`, `html` | `plain` | Control output text formatting |
| `result_format` | string | `unified`, `element_based` | `unified` | Control result structure |

### Chunking Config: New Fields

Text chunking supports these configuration options:

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `max_characters` | integer | 2000 | Maximum characters per chunk |
| `overlap` | integer | 100 | Character overlap between chunks |
| `trim` | boolean | true | Trim whitespace from chunk boundaries |

---

## Element Type Reference

When using `result_format: "element_based"`, results contain elements with these types:

```
title        - Document or section title
heading      - Section heading with level information
paragraph    - Text paragraph
list_item    - Item in a list (ordered, unordered, or task)
table        - Structured table data
image        - Image reference or embedded image
code_block   - Code block with language identifier
block_quote  - Quoted or emphasized text block
page_break   - Page break marker
header       - Document header (running header)
footer       - Document footer (running footer)
```

Each element includes:
- `type` - Element type from list above
- `text` - Element text content (formatted according to `output_format`)
- `metadata` - Rich metadata object containing:
  - `page_number` - Source page number (PDF-specific)
  - `bounding_box` - Visual coordinates if available
  - `confidence_score` - Extraction confidence (0.0-1.0)
  - `hierarchy_level` - Semantic hierarchy level

---

## Breaking Changes in v4.2

✅ **None** - v4.2 is 100% backward compatible with v4.1.

All v4.1 code continues to work without modification.

---

## Troubleshooting

### Q: My v4.1 code stopped working

A: v4.2 is fully backward compatible. If you're experiencing issues:
1. Check you're using v4.2.0 or later
2. Verify dependencies are up to date (especially language-specific bindings)
3. Check for any local version pinning that might prevent upgrade

### Q: How do I know if element-based extraction is supported for my file type?

A: Element-based extraction is supported for all formats that support metadata extraction. Check [supported formats documentation](../features.md) for format-specific capabilities.

### Q: Can I use both `output_format` and `result_format` together?

A: Yes! They work independently:
- `output_format` controls how the text looks (markdown, djot, etc.)
- `result_format` controls the result structure (unified vs elements)
- Use both to get markdown-formatted semantic elements

### Q: What's the performance impact of element-based extraction?

A: Minimal. Element-based extraction uses the same underlying extraction engine with an additional post-processing transformation step. Performance is typically within 5-10% of unified format.

### Q: Can I migrate from Unstructured.io?

A: Yes! Element-based output provides Unstructured.io-compatible structure. See [migration guide](from-unstructured.md) for detailed steps.

### Q: Which languages support the new features?

A: All 10 language bindings support v4.2 features:
- Python ✅
- TypeScript/Node.js ✅
- Ruby ✅
- PHP ✅
- Go ✅
- Java ✅
- C# ✅
- Elixir ✅
- WASM ✅

---

## API Reference Links

- [Extraction API Documentation](../reference/python/extraction.md)
- [Chunking API Documentation](../reference/python/chunking.md)
- [Element Types Reference](../guides/element-based-output.md)
- [Content Formats Reference](../concepts/output-formats.md)
- [Kreuzberg vs Unstructured.io Comparison](../comparisons/kreuzberg-vs-unstructured.md)

---

## Getting Help

- **GitHub Issues**: [Report a bug or request a feature](https://github.com/kreuzberg/kreuzberg/issues)
- **Discussions**: [Join the community discussions](https://github.com/kreuzberg/kreuzberg/discussions)
- **Documentation**: [Full API reference and guides](https://docs.kreuzberg.dev)

---

Last updated: January 25, 2026
