# Type signatures for Kreuzberg document intelligence framework

module Kreuzberg
  VERSION: String

  # Error code constants
  ERROR_CODE_SUCCESS: Integer
  ERROR_CODE_GENERIC: Integer
  ERROR_CODE_PANIC: Integer
  ERROR_CODE_INVALID_ARGUMENT: Integer
  ERROR_CODE_IO: Integer
  ERROR_CODE_PARSING: Integer
  ERROR_CODE_OCR: Integer
  ERROR_CODE_MISSING_DEPENDENCY: Integer

  # Config namespace (defined in lib/kreuzberg/config.rb)
  module Config
    class OCR
      attr_reader backend: String
      attr_reader language: String
      attr_reader tesseract_config: Tesseract?
      attr_reader paddle_ocr_config: PaddleOcr?
      attr_reader element_config: OcrElementConfig?

      def initialize: (?backend: String, ?language: String, ?tesseract_config: (Tesseract | Hash[Symbol, untyped])?, ?paddle_ocr_config: (PaddleOcr | Hash[Symbol, untyped])?, ?element_config: (OcrElementConfig | Hash[Symbol, untyped])?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class Tesseract
      attr_reader options: Hash[Symbol, untyped]

      def initialize: (**untyped options) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class PaddleOcr
      attr_reader language: String?
      attr_reader cache_dir: String?
      attr_reader use_angle_cls: bool?
      attr_reader enable_table_detection: bool?
      attr_reader det_db_thresh: Float?
      attr_reader det_db_box_thresh: Float?
      attr_reader det_db_unclip_ratio: Float?
      attr_reader det_limit_side_len: Integer?
      attr_reader rec_batch_num: Integer?
      def initialize: (?language: String?, ?cache_dir: String?, ?use_angle_cls: bool?, ?enable_table_detection: bool?, ?det_db_thresh: Float?, ?det_db_box_thresh: Float?, ?det_db_unclip_ratio: Float?, ?det_limit_side_len: Integer?, ?rec_batch_num: Integer?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class OcrElementConfig
      attr_reader include_elements: bool
      attr_reader min_level: String?
      attr_reader min_confidence: Float?
      attr_reader build_hierarchy: bool
      def initialize: (?include_elements: bool, ?min_level: String?, ?min_confidence: Float?, ?build_hierarchy: bool) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class Chunking
      attr_reader max_chars: Integer
      attr_reader max_overlap: Integer
      attr_reader preset: String?
      attr_reader embedding: Embedding?
      attr_reader enabled: bool?

      def initialize: (
        ?max_chars: Integer?,
        ?max_overlap: Integer?,
        ?preset: String?,
        ?embedding: (Embedding | Hash[Symbol, untyped])?,
        ?chunk_size: Integer?,
        ?chunk_overlap: Integer?,
        ?enabled: bool
      ) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class Embedding
      attr_reader model: Hash[Symbol, untyped]
      attr_reader normalize: bool?
      attr_reader batch_size: Integer?
      attr_reader show_download_progress: bool?
      attr_reader cache_dir: String?

      def initialize: (
        ?model: Hash[Symbol, untyped],
        ?normalize: bool?,
        ?batch_size: Integer?,
        ?show_download_progress: bool?,
        ?cache_dir: String?
      ) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class LanguageDetection
      attr_reader enabled: bool
      attr_reader min_confidence: Float
      attr_reader detect_multiple: bool

      def initialize: (?enabled: bool, ?min_confidence: Float, ?detect_multiple: bool) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class FontConfig
      attr_accessor enabled: bool
      attr_accessor custom_font_dirs: Array[String]?

      def initialize: (?enabled: bool, ?custom_font_dirs: Array[String]?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class Hierarchy
      attr_reader enabled: bool
      attr_reader k_clusters: Integer
      attr_reader include_bbox: bool
      attr_reader ocr_coverage_threshold: Float?

      def initialize: (?enabled: bool, ?k_clusters: Integer, ?include_bbox: bool, ?ocr_coverage_threshold: Float?) -> void
      def to_h: () -> Hash[Symbol, untyped]
      def self.from_h: (Hash[Symbol, untyped]?) -> Hierarchy?
    end

    class PDF
      attr_reader extract_images: bool
      attr_reader passwords: Array[String]?
      attr_reader extract_metadata: bool
      attr_reader font_config: FontConfig?
      attr_reader hierarchy: Hierarchy?

      def initialize: (?extract_images: bool, ?passwords: (Array[String] | String)?, ?extract_metadata: bool, ?font_config: (FontConfig | Hash[Symbol, untyped])?, ?hierarchy: (Hierarchy | Hash[Symbol, untyped])?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class ImageExtraction
      attr_reader extract_images: bool
      attr_reader target_dpi: Integer
      attr_reader max_image_dimension: Integer
      attr_reader auto_adjust_dpi: bool
      attr_reader min_dpi: Integer
      attr_reader max_dpi: Integer

      def initialize: (
        ?extract_images: bool,
        ?target_dpi: Integer,
        ?max_image_dimension: Integer,
        ?auto_adjust_dpi: bool,
        ?min_dpi: Integer,
        ?max_dpi: Integer
      ) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class ImagePreprocessing
      attr_reader target_dpi: Integer
      attr_reader auto_rotate: bool
      attr_reader deskew: bool
      attr_reader denoise: bool
      attr_reader contrast_enhance: bool
      attr_reader binarization_method: String
      attr_reader invert_colors: bool

      def initialize: (
        ?target_dpi: Integer,
        ?auto_rotate: bool,
        ?deskew: bool,
        ?denoise: bool,
        ?contrast_enhance: bool,
        ?binarization_method: String,
        ?invert_colors: bool
      ) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class TokenReduction
      attr_reader mode: String
      attr_reader preserve_important_words: bool

      def initialize: (?mode: String, ?preserve_important_words: bool) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class PostProcessor
      attr_reader enabled: bool
      attr_reader enabled_processors: Array[String]?
      attr_reader disabled_processors: Array[String]?

      def initialize: (?enabled: bool, ?enabled_processors: Array[String]?, ?disabled_processors: Array[String]?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class HtmlPreprocessing
      attr_reader enabled: bool?
      attr_reader preset: Symbol?
      attr_reader remove_navigation: bool?
      attr_reader remove_forms: bool?

      def initialize: (?enabled: bool?, ?preset: Symbol?, ?remove_navigation: bool?, ?remove_forms: bool?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class HtmlOptions
      attr_reader options: Hash[Symbol, untyped]

      def initialize: (**untyped options) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class KeywordYakeParams
      attr_reader window_size: Integer

      def initialize: (?window_size: Integer) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class KeywordRakeParams
      attr_reader min_word_length: Integer
      attr_reader max_words_per_phrase: Integer

      def initialize: (?min_word_length: Integer, ?max_words_per_phrase: Integer) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class Keywords
      attr_reader algorithm: String?
      attr_reader max_keywords: Integer?
      attr_reader min_score: Float?
      attr_reader ngram_range: Array[Integer]?
      attr_reader language: String?
      attr_reader yake_params: KeywordYakeParams?
      attr_reader rake_params: KeywordRakeParams?

      def initialize: (
        ?algorithm: (Symbol | String)?,
        ?max_keywords: Integer?,
        ?min_score: Float?,
        ?ngram_range: Array[Integer]?,
        ?language: (Symbol | String)?,
        ?yake_params: (KeywordYakeParams | Hash[Symbol, untyped])?,
        ?rake_params: (KeywordRakeParams | Hash[Symbol, untyped])?
      ) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class PageConfig
      attr_reader extract_pages: bool
      attr_reader insert_page_markers: bool
      attr_reader marker_format: String

      def initialize: (?extract_pages: bool, ?insert_page_markers: bool, ?marker_format: String) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    class Extraction
      attr_reader use_cache: bool
      attr_reader enable_quality_processing: bool
      attr_reader force_ocr: bool
      attr_reader ocr: OCR?
      attr_reader chunking: Chunking?
      attr_reader language_detection: LanguageDetection?
      attr_reader pdf_options: PDF?
      attr_reader images: ImageExtraction?
      attr_reader postprocessor: PostProcessor?
      attr_reader token_reduction: TokenReduction?
      attr_reader keywords: Keywords?
      attr_reader html_options: HtmlOptions?
      attr_reader pages: PageConfig?
      attr_reader max_concurrent_extractions: Integer?
      attr_reader output_format: String?
      attr_reader result_format: String?
      attr_reader security_limits: Hash[String, Integer]?

      alias image_extraction images

      def self.from_file: (String path) -> Extraction
      def self.discover: () -> Extraction?
      def initialize: (
        ?use_cache: bool,
        ?enable_quality_processing: bool,
        ?force_ocr: bool,
        ?ocr: (OCR | Hash[Symbol, untyped])?,
        ?chunking: (Chunking | Hash[Symbol, untyped])?,
        ?language_detection: (LanguageDetection | Hash[Symbol, untyped])?,
        ?pdf_options: (PDF | Hash[Symbol, untyped])?,
        ?image_extraction: (ImageExtraction | Hash[Symbol, untyped])?,
        ?postprocessor: (PostProcessor | Hash[Symbol, untyped])?,
        ?token_reduction: (TokenReduction | Hash[Symbol, untyped])?,
        ?keywords: (Keywords | Hash[Symbol, untyped])?,
        ?html_options: (HtmlOptions | Hash[Symbol, untyped])?,
        ?pages: (PageConfig | Hash[Symbol, untyped])?,
        ?max_concurrent_extractions: Integer?,
        ?output_format: String?,
        ?result_format: String?
      ) -> void
      def to_h: () -> Hash[Symbol, untyped]
      def to_json: (*untyped) -> String
      def get_field: (String | Symbol field_name) -> untyped
      def merge: (Extraction | Hash[Symbol, untyped] other) -> Extraction
      def merge!: (Extraction | Hash[Symbol, untyped] other) -> self
      def []: (Symbol | String key) -> untyped
      def []=: (Symbol | String key, untyped value) -> untyped
      def output_format=: (String? value) -> String?
      def result_format=: (String? value) -> String?

      private

      def normalize_config: [T] (T | Hash[Symbol, untyped] | nil value, Class klass) -> T?
      def extract_from_hash: (Hash[Symbol, untyped]? hash, Hash[Symbol, untyped] defaults) -> Hash[Symbol, untyped]
      def assign_attributes: (Hash[Symbol, untyped] params) -> void
      def validate_output_format: (untyped value) -> String?
      def validate_result_format: (untyped value) -> String?
      def update_from_merged: (Extraction merged) -> void
    end

  end

  # Alias for Config::Extraction (for API consistency with other language bindings)
  ExtractionConfig: singleton(Config::Extraction)

  # Alias for Config::PageConfig (for API consistency with other language bindings)
  PageConfig: singleton(Config::PageConfig)

  # Keyword algorithm constants
  module KeywordAlgorithm
    YAKE: Symbol
    RAKE: Symbol
  end

  # Extraction result type
  type extraction_result_hash = {
    content: String,
    mime_type: String,
    metadata_json: String,
    metadata: Hash[String, untyped],
    tables: Array[table_hash]?,
    detected_languages: Array[String]?,
    chunks: Array[chunk_hash]?,
    images: Array[image_hash]?,
    pages: Array[page_content_hash]?,
    elements: Array[element_hash]?,
    ocr_elements: Array[ocr_element_hash]?,
    djot_content: djot_content_hash?
  }

  type page_content_hash = {
    page_number: Integer,
    content: String,
    tables: Array[table_hash],
    images: Array[image_hash]
  }

  type djot_content_hash = {
    plain_text: String,
    blocks: Array[formatted_block_hash],
    metadata_json: String,
    tables: Array[table_hash],
    images: Array[djot_image_hash],
    links: Array[djot_link_hash],
    footnotes: Array[footnote_hash],
    attributes: Hash[String, attributes_hash]?
  }

  type formatted_block_hash = {
    block_type: String,
    level: Integer?,
    content: String?,
    children: Array[formatted_block_hash]?,
    attributes: attributes_hash?
  }

  type djot_image_hash = {
    url: String,
    alt: String?,
    title: String?,
    attributes: attributes_hash?
  }

  type djot_link_hash = {
    url: String,
    text: String,
    title: String?,
    link_type: String?
  }

  type footnote_hash = {
    label: String,
    content: String
  }

  type attributes_hash = Hash[String, String | Integer | bool | Array[String] | nil]

  type element_hash = {
    element_id: String,
    element_type: String,
    text: String,
    metadata: Hash[String, untyped]?
  }

  type ocr_confidence_hash = {
    detection: Float?,
    recognition: Float?
  }

  type ocr_rotation_hash = {
    angle_degrees: Float?,
    confidence: Float?
  }

  type ocr_bounding_geometry_hash = {
    type: String,
    left: Float?,
    top: Float?,
    width: Float?,
    height: Float?,
    points: Array[Array[Float]]?
  }

  type ocr_element_hash = {
    text: String,
    geometry: ocr_bounding_geometry_hash?,
    confidence: ocr_confidence_hash?,
    level: String?,
    rotation: ocr_rotation_hash?,
    page_number: Integer?,
    parent_id: String?,
    backend_metadata: Hash[String, untyped]?
  }

  type table_hash = {
    cells: Array[Array[String]],
    markdown: String,
    page_number: Integer
  }

  type chunk_hash = {
    content: String,
    byte_start: Integer,
    byte_end: Integer,
    token_count: Integer?,
    chunk_index: Integer,
    total_chunks: Integer,
    first_page: Integer?,
    last_page: Integer?,
    embedding: Array[Float]?
  }

  type image_hash = {
    data: String,
    format: String,
    image_index: Integer,
    page_number: Integer?,
    width: Integer?,
    height: Integer?,
    colorspace: String?,
    bits_per_component: Integer?,
    is_mask: bool,
    description: String?,
    ocr_result: extraction_result_hash?
  }

  type config_hash = Hash[Symbol, untyped]
  type config_input = config_hash | _ToH

  interface _ToH
    def to_h: () -> config_hash
  end

  # Extraction result wrapper
  class Result
    # Table structure
    class Table
      attr_reader cells: Array[Array[String]]
      attr_reader markdown: String
      attr_reader page_number: Integer

      def initialize: (cells: Array[Array[String]], markdown: String, page_number: Integer) -> void
      def to_h: () -> table_hash
    end

    # Text chunk
    class Chunk
      attr_reader content: String
      attr_reader byte_start: Integer
      attr_reader byte_end: Integer
      attr_reader token_count: Integer?
      attr_reader chunk_index: Integer
      attr_reader total_chunks: Integer
      attr_reader first_page: Integer?
      attr_reader last_page: Integer?
      attr_reader embedding: Array[Float]?

      def initialize: (
        content: String,
        byte_start: Integer,
        byte_end: Integer,
        token_count: Integer?,
        chunk_index: Integer,
        total_chunks: Integer,
        first_page: Integer?,
        last_page: Integer?,
        embedding: Array[Float]?
      ) -> void
      def to_h: () -> chunk_hash
    end

    class Image
      attr_reader data: String
      attr_reader format: String
      attr_reader image_index: Integer
      attr_reader page_number: Integer?
      attr_reader width: Integer?
      attr_reader height: Integer?
      attr_reader colorspace: String?
      attr_reader bits_per_component: Integer?
      attr_reader is_mask: bool
      attr_reader description: String?
      attr_reader ocr_result: Result?

      def initialize: (
        data: String,
        format: String,
        image_index: Integer,
        page_number: Integer?,
        width: Integer?,
        height: Integer?,
        colorspace: String?,
        bits_per_component: Integer?,
        is_mask: bool,
        description: String?,
        ocr_result: Result?
      ) -> void
      def to_h: () -> image_hash
    end

    # Page content with text and extracted elements
    class PageContent
      attr_reader page_number: Integer
      attr_reader content: String
      attr_reader tables: Array[Table]
      attr_reader images: Array[Image]?
      attr_reader hierarchy: PageHierarchy?

      def initialize: (page_number: Integer, content: String, tables: Array[Table], images: Array[Image]?, hierarchy: PageHierarchy?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    # Hierarchical block element (for page hierarchy)
    class HierarchicalBlock
      attr_reader text: String
      attr_reader font_size: Float?
      attr_reader level: String?
      attr_reader bbox: Array[Float]?

      def initialize: (text: String, font_size: Float?, level: String?, bbox: Array[Float]?) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    # Page hierarchy information
    class PageHierarchy
      attr_reader block_count: Integer
      attr_reader blocks: Array[HierarchicalBlock]

      def initialize: (block_count: Integer, blocks: Array[HierarchicalBlock]) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    # Element bounding box coordinates
    class ElementBoundingBox
      attr_reader x0: Float
      attr_reader y0: Float
      attr_reader x1: Float
      attr_reader y1: Float

      def initialize: (x0: Float, y0: Float, x1: Float, y1: Float) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    # Element metadata
    class ElementMetadataStruct
      attr_reader page_number: Integer?
      attr_reader filename: String?
      attr_reader coordinates: ElementBoundingBox?
      attr_reader element_index: Integer?
      attr_reader additional: Hash[String, String]

      def initialize: (page_number: Integer?, filename: String?, coordinates: ElementBoundingBox?, element_index: Integer?, additional: Hash[String, String]) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    # Structured document element
    class ElementStruct
      attr_reader element_id: String
      attr_reader element_type: String
      attr_reader text: String
      attr_reader metadata: ElementMetadataStruct

      def initialize: (element_id: String, element_type: String, text: String, metadata: ElementMetadataStruct) -> void
      def to_h: () -> Hash[Symbol, untyped]
    end

    # OCR bounding geometry (type and coordinates)
    class OcrBoundingGeometry
      attr_reader type: String
      attr_reader left: Float?
      attr_reader top: Float?
      attr_reader width: Float?
      attr_reader height: Float?
      attr_reader points: Array[Array[Float]]?
      def initialize: (type: String, ?left: Float?, ?top: Float?, ?width: Float?, ?height: Float?, ?points: Array[Array[Float]]?) -> void
      def to_h: () -> ocr_bounding_geometry_hash
    end

    # OCR confidence scores (detection and recognition)
    class OcrConfidence
      attr_reader detection: Float?
      attr_reader recognition: Float?
      def initialize: (?detection: Float?, ?recognition: Float?) -> void
      def to_h: () -> ocr_confidence_hash
    end

    # OCR rotation information
    class OcrRotation
      attr_reader angle_degrees: Float?
      attr_reader confidence: Float?
      def initialize: (?angle_degrees: Float?, ?confidence: Float?) -> void
      def to_h: () -> ocr_rotation_hash
    end

    # OCR text element with geometry and metadata
    class OcrElement
      attr_reader text: String
      attr_reader geometry: OcrBoundingGeometry?
      attr_reader confidence: OcrConfidence?
      attr_reader level: String?
      attr_reader rotation: OcrRotation?
      attr_reader page_number: Integer?
      attr_reader parent_id: String?
      attr_reader backend_metadata: Hash[String, untyped]?
      def initialize: (text: String, ?geometry: OcrBoundingGeometry?, ?confidence: OcrConfidence?, ?level: String?, ?rotation: OcrRotation?, ?page_number: Integer?, ?parent_id: String?, ?backend_metadata: Hash[String, untyped]?) -> void
      def to_h: () -> ocr_element_hash
    end

    # Structured Djot document representation
    class DjotContent
      attr_reader plain_text: String
      attr_reader blocks: Array[DjotContent::FormattedBlock]
      attr_reader metadata_json: String
      attr_reader tables: Array[untyped]
      attr_reader images: Array[DjotContent::DjotImage]
      attr_reader links: Array[DjotContent::DjotLink]
      attr_reader footnotes: Array[DjotContent::Footnote]
      attr_reader attributes: Hash[String, untyped]?

      def initialize: (untyped hash) -> void
      def to_h: () -> Hash[Symbol, untyped]
      def metadata: () -> Hash[untyped, untyped]

      private

      def parse_metadata: (String metadata_json) -> Hash[untyped, untyped]
      def parse_blocks: (Array[untyped] blocks_data) -> Array[FormattedBlock]
      def parse_images: (Array[untyped] images_data) -> Array[DjotImage]
      def parse_links: (Array[untyped] links_data) -> Array[DjotLink]
      def parse_footnotes: (Array[untyped] footnotes_data) -> Array[Footnote]

      class FormattedBlock
        attr_reader block_type: String
        attr_reader level: Integer?
        attr_reader content: String?
        attr_reader children: Array[FormattedBlock]?
        attr_reader attributes: Hash[String, untyped]?

        def initialize: (?untyped hash_or_type, ?children: untyped, ?attributes: untyped, ?content: untyped, ?level: untyped, ?block_type: untyped) -> void
        def to_h: () -> Hash[Symbol, untyped]
      end

      class DjotImage
        attr_reader url: String
        attr_reader alt: String?
        attr_reader title: String?
        attr_reader width: Integer?
        attr_reader height: Integer?

        def initialize: (?untyped hash_or_url, ?alt: untyped, ?title: untyped, ?width: untyped, ?height: untyped, ?url: untyped, ?src: untyped) -> void
        def src: () -> String
        def to_h: () -> Hash[Symbol, untyped]
      end

      class DjotLink
        attr_reader url: String
        attr_reader text: String?
        attr_reader title: String?
        attr_reader link_type: String?

        def initialize: (?untyped hash_or_url, ?text: untyped, ?title: untyped, ?url: untyped, ?href: untyped, ?link_type: untyped) -> void
        def href: () -> String
        def to_h: () -> Hash[Symbol, untyped]
      end

      class Footnote
        attr_reader label: String
        attr_reader content: String

        def initialize: (label: String, content: String) -> void
        def to_h: () -> footnote_hash
      end
    end

    attr_reader content: String
    attr_reader mime_type: String
    attr_reader metadata: Hash[untyped, untyped]
    attr_reader metadata_json: String
    attr_reader tables: Array[Table]
    attr_reader detected_languages: Array[String]?
    attr_reader chunks: Array[Chunk]?
    attr_reader images: Array[Image]?
    attr_reader pages: Array[PageContent]?
    attr_reader elements: Array[ElementStruct]?
    attr_reader ocr_elements: Array[OcrElement]?
    attr_reader djot_content: DjotContent?

    def initialize: (extraction_result_hash hash) -> void
    def to_h: () -> Hash[Symbol, untyped]
    def to_json: (*untyped) -> String

    def page_count: () -> Integer
    def chunk_count: () -> Integer
    def detected_language: () -> String?
    def metadata_field: (String | Symbol name) -> untyped

    private

    def parse_metadata: (String metadata_json) -> Hash[untyped, untyped]
    def parse_tables: (Array[table_hash]? tables_data) -> Array[Table]
    def parse_detected_languages: (Array[String]? langs_data) -> Array[String]?
    def parse_chunks: (Array[chunk_hash]? chunks_data) -> Array[Chunk]?
    def parse_images: (Array[image_hash]? images_data) -> Array[Image]?
    def parse_pages: (Array[page_content_hash]? pages_data) -> Array[PageContent]?
    def parse_elements: (Array[untyped]? elements_data) -> Array[ElementStruct]?
    def parse_element: (Hash[String, untyped] element_hash) -> ElementStruct
    def parse_element_coordinates: (Hash[String, untyped]? coordinates_data) -> ElementBoundingBox?
    def parse_ocr_elements: (Array[ocr_element_hash]? ocr_elements_data) -> Array[OcrElement]?
    def parse_page_hierarchy: (Hash[String, untyped]? hierarchy_data) -> PageHierarchy?
    def parse_djot_content: (Hash[String, untyped]? djot_data) -> DjotContent?
    def get_value: (Hash[String | Symbol, untyped] hash, String key, ?untyped default) -> untyped
    def serialize_tables: () -> Array[table_hash]
    def serialize_chunks: () -> Array[chunk_hash]?
    def serialize_images: () -> Array[image_hash]?
    def serialize_pages: () -> Array[Hash[Symbol, untyped]]?
    def serialize_elements: () -> Array[Hash[Symbol, untyped]]?
  end

  # Module methods (extraction API)
  def self.extract_file_sync: (
    path: String | Pathname,
    ?mime_type: String?,
    ?config: config_input?
  ) -> Result

  def self.extract_bytes_sync: (
    data: String,
    mime_type: String,
    ?config: config_input?
  ) -> Result

  def self.batch_extract_files_sync: (
    paths: Array[String | Pathname],
    ?config: config_input?
  ) -> Array[Result]

  def self.batch_extract_bytes_sync: (
    data_array: Array[String],
    mime_types: Array[String],
    ?config: config_input?
  ) -> Array[Result]

  def self.extract_file: (
    path: String | Pathname,
    ?mime_type: String?,
    ?config: config_input?
  ) -> Result

  def self.extract_bytes: (
    data: String,
    mime_type: String,
    ?config: config_input?
  ) -> Result

  def self.batch_extract_files: (
    paths: Array[String | Pathname],
    ?config: config_input?
  ) -> Array[Result]

  def self.batch_extract_bytes: (
    data_array: Array[String],
    mime_types: Array[String],
    ?config: config_input?
  ) -> Array[Result]

  # Cache API
  def self.clear_cache: () -> void
  def self.cache_stats: () -> Hash[Symbol | String, Integer]

  # Config loading (native methods)
  def self._config_from_file_native: (String path) -> Hash[Symbol, untyped]
  def self._config_discover_native: () -> Hash[Symbol, untyped]?

  # Error introspection (native methods)
  def self._last_error_code_native: () -> Integer
  def self._last_panic_context_json_native: () -> String?
  def self._get_error_details_native: () -> Hash[String, untyped]
  def self._classify_error_native: (String message) -> Hash[String, untyped]
  def self._error_code_name_native: (Integer code) -> String
  def self._error_code_description_native: (Integer code) -> String

  # MIME type detection
  def self.detect_mime_type: (String data) -> String
  def self.detect_mime_type_from_path: (String path) -> String
  def self.get_extensions_for_mime: (String mime_type) -> Array[String]
  def self.validate_mime_type: (String mime_type) -> String

  # Validation native methods
  def self._validate_binarization_method_native: (String method) -> Integer
  def self._validate_ocr_backend_native: (String backend) -> Integer
  def self._validate_language_code_native: (String code) -> Integer
  def self._validate_token_reduction_level_native: (String level) -> Integer
  def self._validate_tesseract_psm_native: (Integer psm) -> Integer
  def self._validate_tesseract_oem_native: (Integer oem) -> Integer
  def self._validate_output_format_native: (String format) -> Integer
  def self._validate_confidence_native: (Float confidence) -> Integer
  def self._validate_dpi_native: (Integer dpi) -> Integer
  def self._validate_chunking_params_native: (Integer max_chars, Integer max_overlap) -> Integer
  def self._get_valid_binarization_methods_native: () -> String
  def self._get_valid_language_codes_native: () -> String
  def self._get_valid_ocr_backends_native: () -> String
  def self._get_valid_token_reduction_levels_native: () -> String

  # Config wrapper functions
  def self._config_to_json_native: (String config_json) -> String
  def self._config_get_field_native: (String config_json, String field_name) -> untyped
  def self._config_merge_native: (String base_json, String override_json) -> String

  # Result wrapper functions
  def self._result_page_count_native: (untyped result) -> Integer
  def self._result_chunk_count_native: (untyped result) -> Integer
  def self._result_detected_language_native: (untyped result) -> String?
  def self._result_metadata_field_native: (untyped result, String field_name) -> untyped

  # Plugin registration
  def self.register_post_processor: (String name, _PostProcessor processor, ?stage: Symbol?) -> void
  def self.unregister_post_processor: (String name) -> void
  def self.clear_post_processors: () -> void
  def self.register_validator: (String name, _Validator validator, ?priority: Integer?) -> void
  def self.unregister_validator: (String name) -> void
  def self.clear_validators: () -> void
  def self.register_ocr_backend: (String name, _OcrBackend backend) -> void
  def self.unregister_ocr_backend: (String name) -> void
  def self.list_ocr_backends: () -> Array[String]
  def self.clear_ocr_backends: () -> void
  def self.unregister_document_extractor: (String name) -> void
  def self.list_document_extractors: () -> Array[String]
  def self.clear_document_extractors: () -> void
  def self.list_post_processors: () -> Array[String]
  def self.list_validators: () -> Array[String]

  interface _PostProcessor
    def call: (extraction_result_hash result) -> extraction_result_hash
  end

  interface _Validator
    def call: (extraction_result_hash result) -> void
  end

  interface _OcrBackend
    def name: () -> String
    def process_image: (String image_bytes, Hash[Symbol, untyped] config) -> String
  end

  module ErrorContext
    def self.last_error_code: () -> Integer
    def self.last_panic_context: () -> Errors::PanicContext?
    def self.last_panic_context_json: () -> String?
    def self.error_details: () -> Hash[String, untyped]
    def self.classify_error: (String message) -> (Hash[String, untyped] | Integer)
    def self.error_code_name: (Integer code) -> String
    def self.error_code_description: (Integer code) -> String
  end

  module Errors
    # Panic context information from FFI error introspection
    class PanicContext
      attr_reader file: String
      attr_reader line: Integer
      attr_reader function: String
      attr_reader message: String
      attr_reader timestamp_secs: Integer

      def initialize: (
        file: String,
        line: Integer,
        function: String,
        message: String,
        timestamp_secs: Integer
      ) -> void
      def to_s: () -> String
      def to_h: () -> Hash[Symbol, String | Integer]
      def self.from_json: (String) -> PanicContext?

      private

      def self.with_defaults: (Hash[Symbol, untyped] sliced) -> {file: String, line: Integer, function: String, message: String, timestamp_secs: Integer}
    end

    class Error < StandardError
      attr_reader panic_context: PanicContext?
      attr_reader error_code: Integer?

      def initialize: (String message, ?panic_context: PanicContext?, ?error_code: Integer?) -> void
    end

    class ValidationError < Error
    end

    class ParsingError < Error
      attr_reader context: Hash[untyped, untyped]?

      def initialize: (String message, ?context: Hash[untyped, untyped]?, ?panic_context: PanicContext?, ?error_code: Integer?) -> void
    end

    class OCRError < Error
      attr_reader context: Hash[untyped, untyped]?

      def initialize: (String message, ?context: Hash[untyped, untyped]?, ?panic_context: PanicContext?, ?error_code: Integer?) -> void
    end

    class MissingDependencyError < Error
      attr_reader dependency: String?

      def initialize: (String message, ?dependency: String?, ?panic_context: PanicContext?, ?error_code: Integer?) -> void
    end

    class IOError < Error
    end

    class PluginError < Error
    end

    class UnsupportedFormatError < Error
    end
  end

  # Internal modules (prepended to Kreuzberg singleton)
  # These are not checked by steep - see Steepfile
  module CacheAPI : Object
  end

  module ExtractionAPI : Object
  end

  module PostProcessorProtocol
    def call: (extraction_result_hash result) -> extraction_result_hash
  end

  module ValidatorProtocol
    def call: (extraction_result_hash result) -> void
  end

  module OcrBackendProtocol
    def name: () -> String
    def process_image: (String image_bytes, Hash[Symbol, untyped] config) -> String
  end
end
