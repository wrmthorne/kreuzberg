# Internal modules - not part of public API but fully typed

module Kreuzberg
  module SetupLibPath
    # Public method
    def configure: () -> void
    def self.configure: () -> void

    # Private methods (module_function makes them both instance and class methods)
    def prepend_env: (String key, String value, ?separator: String) -> void
    def self.prepend_env: (String key, String value, ?separator: String) -> void
    def fix_macos_install_name: (String lib_dir) -> void
    def self.fix_macos_install_name: (String lib_dir) -> void
    def macos_bundle: (String lib_dir) -> String?
    def self.macos_bundle: (String lib_dir) -> String?
    def ensure_install_name: (String bundle) -> void
    def self.ensure_install_name: (String bundle) -> void
    def ensure_loader_rpath: (String bundle) -> void
    def self.ensure_loader_rpath: (String bundle) -> void
  end

  module CLI
    # All methods are both instance and class methods due to module_function
    def extract: (String path, ?output: String, ?ocr: bool) -> String
    def self.extract: (String path, ?output: String, ?ocr: bool) -> String
    def detect: (String path) -> String
    def self.detect: (String path) -> String
    def version: () -> String
    def self.version: () -> String
    def help: () -> String
    def self.help: () -> String
  end

  module CLIProxy
    class Error < Kreuzberg::Errors::Error
    end

    class MissingBinaryError < Error
    end

    class CLIExecutionError < Error
      attr_reader stderr: String
      attr_reader status: Integer

      def initialize: (String message, stderr: String, status: Integer) -> void
    end

    # All methods are both instance and class methods due to module_function
    def call: (Array[String] argv) -> String
    def self.call: (Array[String] argv) -> String
    def find_cli_binary: () -> Pathname
    def self.find_cli_binary: () -> Pathname
    def root_path: () -> Pathname
    def self.root_path: () -> Pathname
    def lib_path: () -> Pathname
    def self.lib_path: () -> Pathname
    def search_paths: (String binary_name) -> Array[Pathname]
    def self.search_paths: (String binary_name) -> Array[Pathname]
    def missing_binary_message: () -> String
    def self.missing_binary_message: () -> String
  end

  module APIProxy
    class Error < Kreuzberg::Errors::Error
    end

    class MissingBinaryError < Error
    end

    class ServerError < Error
    end

    class Server
      attr_reader port: Integer
      attr_reader host: String
      attr_reader process: Process::Status?

      def initialize: (?port: Integer, ?host: String) -> void
      def start: () -> void
      def stop: () -> void
      def running?: () -> bool
      def health_check: () -> bool
    end

    # Module function methods are both instance and class methods
    def run: (?port: Integer, ?host: String) { (Server) -> untyped } -> untyped
    def self.run: (?port: Integer, ?host: String) { (Server) -> untyped } -> untyped
    def start_server: (?port: Integer?) -> Server
    def self.start_server: (?port: Integer?) -> Server
    def extract_file: (String path, ?mime_type: String?, ?config: Hash[Symbol, untyped]?, ?server: Server?) -> Kreuzberg::Result
    def self.extract_file: (String path, ?mime_type: String?, ?config: Hash[Symbol, untyped]?, ?server: Server?) -> Kreuzberg::Result
    def batch_extract: (Array[String] paths, ?config: Hash[Symbol, untyped]?, ?server: Server?) -> Array[Kreuzberg::Result]
    def self.batch_extract: (Array[String] paths, ?config: Hash[Symbol, untyped]?, ?server: Server?) -> Array[Kreuzberg::Result]
    def find_api_binary: () -> Pathname
    def self.find_api_binary: () -> Pathname
    def missing_binary_message: () -> String
    def self.missing_binary_message: () -> String
  end

  module MCPProxy
    class Error < Kreuzberg::Errors::Error
    end

    class MissingBinaryError < Error
    end

    class ServerError < Error
    end

    class Server
      attr_reader pid: Integer?
      attr_reader transport: String

      def initialize: (?transport: String) -> void
      def start: () -> (Integer | nil)
      def stop: () -> void
      def running?: () -> bool
      def send_message: (Hash[untyped, untyped] message) -> void
      def read_message: () -> (Hash[untyped, untyped] | nil)

      private

      def start_stdio: (Pathname binary) -> nil
      def start_sse: (Pathname binary) -> (Integer | nil)
      def close_pipes: () -> void
    end

    # Module function methods are both instance and class methods
    def run: (?transport: String) { (Server) -> untyped } -> untyped
    def self.run: (?transport: String) { (Server) -> untyped } -> untyped
    def extract_file: (String path, ?mime_type: String?, ?config: Hash[Symbol, untyped]?) -> Kreuzberg::Result
    def self.extract_file: (String path, ?mime_type: String?, ?config: Hash[Symbol, untyped]?) -> Kreuzberg::Result
    def batch_extract: (Array[String] paths, ?config: Hash[Symbol, untyped]?) -> Array[Kreuzberg::Result]
    def self.batch_extract: (Array[String] paths, ?config: Hash[Symbol, untyped]?) -> Array[Kreuzberg::Result]
    def find_mcp_binary: () -> Pathname
    def self.find_mcp_binary: () -> Pathname
    def missing_binary_message: () -> String
    def self.missing_binary_message: () -> String
  end

  # Cache API module (prepended to Kreuzberg singleton class)
  module CacheAPI
    @__cache_tracker: Hash[Symbol, Integer]

    def clear_cache: () -> void
    def cache_stats: () -> Hash[Symbol | String, Integer]

    private

    def record_cache_entry!: (Kreuzberg::Result | Array[Kreuzberg::Result] results, Hash[Symbol, untyped] opts) -> void
    def reset_cache_tracker!: () -> nil

    # Native methods (defined in Rust)
    def native_clear_cache: () -> void
    def native_cache_stats: () -> Hash[Symbol | String, Integer]
  end

  # Extraction API module (prepended to Kreuzberg singleton class)
  module ExtractionAPI
    def extract_file_sync: (String | Pathname path, ?mime_type: String?, ?config: config_input?) -> Result
    def extract_bytes_sync: (String data, String mime_type, ?config: config_input?) -> Result
    def batch_extract_files_sync: (Array[String | Pathname] paths, ?config: config_input?) -> Array[Result]
    def extract_file: (String | Pathname path, ?mime_type: String?, ?config: config_input?) -> Result
    def extract_bytes: (String data, String mime_type, ?config: config_input?) -> Result
    def batch_extract_files: (Array[String | Pathname] paths, ?config: config_input?) -> Array[Result]
    def batch_extract_bytes_sync: (Array[String] data_array, Array[String] mime_types, ?config: config_input?) -> Array[Result]
    def batch_extract_bytes: (Array[String] data_array, Array[String] mime_types, ?config: config_input?) -> Array[Result]

    def normalize_config: (config_input? config) -> Hash[Symbol, untyped]

    # Native methods (defined in Rust)
    def native_extract_file_sync: (String path, ?String? mime_type, **untyped opts) -> extraction_result_hash
    def native_extract_bytes_sync: (String data, String mime_type, **untyped opts) -> extraction_result_hash
    def native_batch_extract_files_sync: (Array[String] paths, **untyped opts) -> Array[extraction_result_hash]
    def native_extract_file: (String path, ?String? mime_type, **untyped opts) -> extraction_result_hash
    def native_extract_bytes: (String data, String mime_type, **untyped opts) -> extraction_result_hash
    def native_batch_extract_files: (Array[String] paths, **untyped opts) -> Array[extraction_result_hash]
    def native_batch_extract_bytes_sync: (Array[String] data_array, Array[String] mime_types, **untyped opts) -> Array[extraction_result_hash]
    def native_batch_extract_bytes: (Array[String] data_array, Array[String] mime_types, **untyped opts) -> Array[extraction_result_hash]

    # Cache API methods (from prepended CacheAPI module)
    def record_cache_entry!: (Kreuzberg::Result | Array[Kreuzberg::Result] results, Hash[Symbol, untyped] opts) -> void
  end
end
