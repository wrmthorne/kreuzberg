// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// Category: contract

package e2e

import "testing"

func TestContractApiBatchBytesAsync(t *testing.T) {
	results := runBatchExtractionAsync(t, []string{"pdfs/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiBatchBytesSync(t *testing.T) {
	results := runBatchExtraction(t, []string{"pdfs/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiBatchFileAsync(t *testing.T) {
	results := runBatchExtractionAsync(t, []string{"pdfs/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiBatchFileSync(t *testing.T) {
	results := runBatchExtraction(t, []string{"pdfs/fake_memo.pdf"}, nil)
	if len(results) == 0 {
		t.Fatal("expected at least one result from batch extraction")
	}
	result := results[0]
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractBytesAsync(t *testing.T) {
	result := runExtractionBytesAsync(t, "pdfs/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractBytesSync(t *testing.T) {
	result := runExtractionBytes(t, "pdfs/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractFileAsync(t *testing.T) {
	result := runExtractionAsync(t, "pdfs/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractApiExtractFileSync(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", nil)
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertContentContainsAny(t, result, []string{"May 5, 2023", "Mallori"})
}

func TestContractConfigChunking(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"chunking": {
	"max_chars": 500,
	"overlap": 50
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertChunks(t, result, intPtr(1), nil, boolPtr(true), nil)
}

func TestContractConfigForceOcr(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"force_ocr": true
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 5)
}

func TestContractConfigImages(t *testing.T) {
	result := runExtraction(t, "pdfs/embedded_images_tables.pdf", []byte(`{
"images": {
	"extract": true,
	"format": "png"
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertImages(t, result, intPtr(1), nil, nil)
}

func TestContractConfigLanguageDetection(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"language_detection": {
	"enabled": true
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
	assertDetectedLanguages(t, result, []string{"eng"}, floatPtr(0.5))
}

func TestContractConfigPages(t *testing.T) {
	result := runExtraction(t, "pdfs/multi_page.pdf", []byte(`{
"pages": {
	"end": 3,
	"start": 1
}
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractConfigUseCacheFalse(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"use_cache": false
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatDjot(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"output_format": "djot"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatHtml(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"output_format": "html"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatMarkdown(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"output_format": "markdown"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractOutputFormatPlain(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"output_format": "plain"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}

func TestContractResultFormatElementBased(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"result_format": "element_based"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertElements(t, result, intPtr(1), nil)
}

func TestContractResultFormatUnified(t *testing.T) {
	result := runExtraction(t, "pdfs/fake_memo.pdf", []byte(`{
"result_format": "unified"
}`))
	assertExpectedMime(t, result, []string{"application/pdf"})
	assertMinContentLength(t, result, 10)
}
